Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    LBRACKET
    RBRACKET

Grammar

Rule 0     S' -> program
Rule 1     program -> global_items
Rule 2     global_items -> global_items global_item
Rule 3     global_items -> global_item
Rule 4     global_item -> function_def
Rule 5     global_item -> stmt
Rule 6     function_def -> type_specifier ID LPAREN param_list RPAREN block
Rule 7     param_list -> param_list COMMA param
Rule 8     param_list -> param
Rule 9     param_list -> empty
Rule 10    param -> type_specifier ID
Rule 11    type_specifier -> INT
Rule 12    type_specifier -> FLOAT
Rule 13    type_specifier -> DOUBLE
Rule 14    type_specifier -> CHAR
Rule 15    type_specifier -> BOOL
Rule 16    type_specifier -> STRING
Rule 17    block -> LBRACE stmt_list RBRACE
Rule 18    stmt_list -> stmt_list stmt
Rule 19    stmt_list -> empty
Rule 20    stmt -> decl_stmt
Rule 21    stmt -> expr_stmt
Rule 22    stmt -> if_stmt
Rule 23    stmt -> while_stmt
Rule 24    stmt -> for_stmt
Rule 25    stmt -> io_stmt
Rule 26    stmt -> return_stmt
Rule 27    stmt -> break_stmt
Rule 28    stmt -> continue_stmt
Rule 29    stmt -> block
Rule 30    decl_stmt -> type_specifier init_decl SEMICOLON
Rule 31    decl_stmt -> type_specifier ID SEMICOLON
Rule 32    init_decl -> ID ASSIGN expression
Rule 33    expr_stmt -> assignment SEMICOLON
Rule 34    expr_stmt -> unary_inc_dec SEMICOLON
Rule 35    expr_stmt -> compound_assignment SEMICOLON
Rule 36    assignment -> ID ASSIGN expression
Rule 37    unary_inc_dec -> ID INC
Rule 38    unary_inc_dec -> ID DEC
Rule 39    compound_assignment -> ID PLUS_ASSIGN expression
Rule 40    compound_assignment -> ID MINUS_ASSIGN expression
Rule 41    compound_assignment -> ID TIMES_ASSIGN expression
Rule 42    compound_assignment -> ID DIVIDE_ASSIGN expression
Rule 43    expression -> expression PLUS expression
Rule 44    expression -> expression MINUS expression
Rule 45    expression -> expression TIMES expression
Rule 46    expression -> expression DIVIDE expression
Rule 47    expression -> expression MOD expression
Rule 48    expression -> expression EQ expression
Rule 49    expression -> expression NEQ expression
Rule 50    expression -> expression LT expression
Rule 51    expression -> expression GT expression
Rule 52    expression -> expression LE expression
Rule 53    expression -> expression GE expression
Rule 54    expression -> expression AND expression
Rule 55    expression -> expression OR expression
Rule 56    expression -> MINUS expression
Rule 57    expression -> NOT expression
Rule 58    expression -> LPAREN expression RPAREN
Rule 59    expression -> INT_CONST
Rule 60    expression -> FLOAT_CONST
Rule 61    expression -> STRING_LITERAL
Rule 62    expression -> CHAR_CONST
Rule 63    expression -> ID
Rule 64    while_stmt -> WHILE LPAREN expression RPAREN stmt
Rule 65    for_stmt -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt
Rule 66    for_init -> decl_stmt
Rule 67    for_init -> assignment
Rule 68    for_init -> unary_inc_dec
Rule 69    for_init -> compound_assignment
Rule 70    for_init -> empty
Rule 71    for_cond -> expression
Rule 72    for_cond -> empty
Rule 73    for_iter -> expr_iter
Rule 74    for_iter -> empty
Rule 75    expr_iter -> ID INC
Rule 76    expr_iter -> ID DEC
Rule 77    expr_iter -> assignment
Rule 78    expr_iter -> compound_assignment
Rule 79    io_stmt -> cout_stmt SEMICOLON
Rule 80    io_stmt -> cin_stmt SEMICOLON
Rule 81    cout_stmt -> COUT insertion_list
Rule 82    insertion_list -> LSHIFT insertion_items
Rule 83    insertion_items -> insertion_items LSHIFT insertion_item
Rule 84    insertion_items -> insertion_item
Rule 85    insertion_item -> expression
Rule 86    insertion_item -> ENDL
Rule 87    cin_stmt -> CIN extraction_list
Rule 88    extraction_list -> RSHIFT extraction_items
Rule 89    extraction_items -> extraction_items RSHIFT extraction_target
Rule 90    extraction_items -> extraction_target
Rule 91    extraction_target -> ID
Rule 92    if_stmt -> IF LPAREN expression RPAREN stmt ELSE stmt
Rule 93    if_stmt -> IF LPAREN expression RPAREN stmt
Rule 94    return_stmt -> RETURN expression SEMICOLON
Rule 95    return_stmt -> RETURN SEMICOLON
Rule 96    break_stmt -> BREAK SEMICOLON
Rule 97    continue_stmt -> CONTINUE SEMICOLON
Rule 98    empty -> <empty>

Terminals, with rules where they appear

AND                  : 54
ASSIGN               : 32 36
BOOL                 : 15
BREAK                : 96
CHAR                 : 14
CHAR_CONST           : 62
CIN                  : 87
COMMA                : 7
CONTINUE             : 97
COUT                 : 81
DEC                  : 38 76
DIVIDE               : 46
DIVIDE_ASSIGN        : 42
DOUBLE               : 13
ELSE                 : 92
ENDL                 : 86
EQ                   : 48
FLOAT                : 12
FLOAT_CONST          : 60
FOR                  : 65
GE                   : 53
GT                   : 51
ID                   : 6 10 31 32 36 37 38 39 40 41 42 63 75 76 91
IF                   : 92 93
INC                  : 37 75
INT                  : 11
INT_CONST            : 59
LBRACE               : 17
LBRACKET             : 
LE                   : 52
LPAREN               : 6 58 64 65 92 93
LSHIFT               : 82 83
LT                   : 50
MINUS                : 44 56
MINUS_ASSIGN         : 40
MOD                  : 47
NEQ                  : 49
NOT                  : 57
OR                   : 55
PLUS                 : 43
PLUS_ASSIGN          : 39
RBRACE               : 17
RBRACKET             : 
RETURN               : 94 95
RPAREN               : 6 58 64 65 92 93
RSHIFT               : 88 89
SEMICOLON            : 30 31 33 34 35 65 65 79 80 94 95 96 97
STRING               : 16
STRING_LITERAL       : 61
TIMES                : 45
TIMES_ASSIGN         : 41
WHILE                : 64
error                : 

Nonterminals, with rules where they appear

assignment           : 33 67 77
block                : 6 29
break_stmt           : 27
cin_stmt             : 80
compound_assignment  : 35 69 78
continue_stmt        : 28
cout_stmt            : 79
decl_stmt            : 20 66
empty                : 9 19 70 72 74
expr_iter            : 73
expr_stmt            : 21
expression           : 32 36 39 40 41 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 57 58 64 71 85 92 93 94
extraction_items     : 88 89
extraction_list      : 87
extraction_target    : 89 90
for_cond             : 65
for_init             : 65
for_iter             : 65
for_stmt             : 24
function_def         : 4
global_item          : 2 3
global_items         : 1 2
if_stmt              : 22
init_decl            : 30
insertion_item       : 83 84
insertion_items      : 82 83
insertion_list       : 81
io_stmt              : 25
param                : 7 8
param_list           : 6 7
program              : 0
return_stmt          : 26
stmt                 : 5 18 64 65 92 92 93
stmt_list            : 17 18
type_specifier       : 6 10 30 31
unary_inc_dec        : 34 68
while_stmt           : 23

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . global_items
    (2) global_items -> . global_items global_item
    (3) global_items -> . global_item
    (4) global_item -> . function_def
    (5) global_item -> . stmt
    (6) function_def -> . type_specifier ID LPAREN param_list RPAREN block
    (20) stmt -> . decl_stmt
    (21) stmt -> . expr_stmt
    (22) stmt -> . if_stmt
    (23) stmt -> . while_stmt
    (24) stmt -> . for_stmt
    (25) stmt -> . io_stmt
    (26) stmt -> . return_stmt
    (27) stmt -> . break_stmt
    (28) stmt -> . continue_stmt
    (29) stmt -> . block
    (11) type_specifier -> . INT
    (12) type_specifier -> . FLOAT
    (13) type_specifier -> . DOUBLE
    (14) type_specifier -> . CHAR
    (15) type_specifier -> . BOOL
    (16) type_specifier -> . STRING
    (30) decl_stmt -> . type_specifier init_decl SEMICOLON
    (31) decl_stmt -> . type_specifier ID SEMICOLON
    (33) expr_stmt -> . assignment SEMICOLON
    (34) expr_stmt -> . unary_inc_dec SEMICOLON
    (35) expr_stmt -> . compound_assignment SEMICOLON
    (92) if_stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (93) if_stmt -> . IF LPAREN expression RPAREN stmt
    (64) while_stmt -> . WHILE LPAREN expression RPAREN stmt
    (65) for_stmt -> . FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt
    (79) io_stmt -> . cout_stmt SEMICOLON
    (80) io_stmt -> . cin_stmt SEMICOLON
    (94) return_stmt -> . RETURN expression SEMICOLON
    (95) return_stmt -> . RETURN SEMICOLON
    (96) break_stmt -> . BREAK SEMICOLON
    (97) continue_stmt -> . CONTINUE SEMICOLON
    (17) block -> . LBRACE stmt_list RBRACE
    (36) assignment -> . ID ASSIGN expression
    (37) unary_inc_dec -> . ID INC
    (38) unary_inc_dec -> . ID DEC
    (39) compound_assignment -> . ID PLUS_ASSIGN expression
    (40) compound_assignment -> . ID MINUS_ASSIGN expression
    (41) compound_assignment -> . ID TIMES_ASSIGN expression
    (42) compound_assignment -> . ID DIVIDE_ASSIGN expression
    (81) cout_stmt -> . COUT insertion_list
    (87) cin_stmt -> . CIN extraction_list

    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    DOUBLE          shift and go to state 20
    CHAR            shift and go to state 21
    BOOL            shift and go to state 22
    STRING          shift and go to state 23
    IF              shift and go to state 27
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    LBRACE          shift and go to state 35
    ID              shift and go to state 7
    COUT            shift and go to state 36
    CIN             shift and go to state 37

    program                        shift and go to state 1
    global_items                   shift and go to state 2
    global_item                    shift and go to state 3
    function_def                   shift and go to state 4
    stmt                           shift and go to state 5
    type_specifier                 shift and go to state 6
    block                          shift and go to state 8
    decl_stmt                      shift and go to state 9
    expr_stmt                      shift and go to state 10
    if_stmt                        shift and go to state 11
    while_stmt                     shift and go to state 12
    for_stmt                       shift and go to state 13
    io_stmt                        shift and go to state 14
    return_stmt                    shift and go to state 15
    break_stmt                     shift and go to state 16
    continue_stmt                  shift and go to state 17
    assignment                     shift and go to state 24
    unary_inc_dec                  shift and go to state 25
    compound_assignment            shift and go to state 26
    cout_stmt                      shift and go to state 30
    cin_stmt                       shift and go to state 31

state 1

    (0) S' -> program .



state 2

    (1) program -> global_items .
    (2) global_items -> global_items . global_item
    (4) global_item -> . function_def
    (5) global_item -> . stmt
    (6) function_def -> . type_specifier ID LPAREN param_list RPAREN block
    (20) stmt -> . decl_stmt
    (21) stmt -> . expr_stmt
    (22) stmt -> . if_stmt
    (23) stmt -> . while_stmt
    (24) stmt -> . for_stmt
    (25) stmt -> . io_stmt
    (26) stmt -> . return_stmt
    (27) stmt -> . break_stmt
    (28) stmt -> . continue_stmt
    (29) stmt -> . block
    (11) type_specifier -> . INT
    (12) type_specifier -> . FLOAT
    (13) type_specifier -> . DOUBLE
    (14) type_specifier -> . CHAR
    (15) type_specifier -> . BOOL
    (16) type_specifier -> . STRING
    (30) decl_stmt -> . type_specifier init_decl SEMICOLON
    (31) decl_stmt -> . type_specifier ID SEMICOLON
    (33) expr_stmt -> . assignment SEMICOLON
    (34) expr_stmt -> . unary_inc_dec SEMICOLON
    (35) expr_stmt -> . compound_assignment SEMICOLON
    (92) if_stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (93) if_stmt -> . IF LPAREN expression RPAREN stmt
    (64) while_stmt -> . WHILE LPAREN expression RPAREN stmt
    (65) for_stmt -> . FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt
    (79) io_stmt -> . cout_stmt SEMICOLON
    (80) io_stmt -> . cin_stmt SEMICOLON
    (94) return_stmt -> . RETURN expression SEMICOLON
    (95) return_stmt -> . RETURN SEMICOLON
    (96) break_stmt -> . BREAK SEMICOLON
    (97) continue_stmt -> . CONTINUE SEMICOLON
    (17) block -> . LBRACE stmt_list RBRACE
    (36) assignment -> . ID ASSIGN expression
    (37) unary_inc_dec -> . ID INC
    (38) unary_inc_dec -> . ID DEC
    (39) compound_assignment -> . ID PLUS_ASSIGN expression
    (40) compound_assignment -> . ID MINUS_ASSIGN expression
    (41) compound_assignment -> . ID TIMES_ASSIGN expression
    (42) compound_assignment -> . ID DIVIDE_ASSIGN expression
    (81) cout_stmt -> . COUT insertion_list
    (87) cin_stmt -> . CIN extraction_list

    $end            reduce using rule 1 (program -> global_items .)
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    DOUBLE          shift and go to state 20
    CHAR            shift and go to state 21
    BOOL            shift and go to state 22
    STRING          shift and go to state 23
    IF              shift and go to state 27
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    LBRACE          shift and go to state 35
    ID              shift and go to state 7
    COUT            shift and go to state 36
    CIN             shift and go to state 37

    global_item                    shift and go to state 38
    function_def                   shift and go to state 4
    stmt                           shift and go to state 5
    type_specifier                 shift and go to state 6
    block                          shift and go to state 8
    decl_stmt                      shift and go to state 9
    expr_stmt                      shift and go to state 10
    if_stmt                        shift and go to state 11
    while_stmt                     shift and go to state 12
    for_stmt                       shift and go to state 13
    io_stmt                        shift and go to state 14
    return_stmt                    shift and go to state 15
    break_stmt                     shift and go to state 16
    continue_stmt                  shift and go to state 17
    assignment                     shift and go to state 24
    unary_inc_dec                  shift and go to state 25
    compound_assignment            shift and go to state 26
    cout_stmt                      shift and go to state 30
    cin_stmt                       shift and go to state 31

state 3

    (3) global_items -> global_item .

    INT             reduce using rule 3 (global_items -> global_item .)
    FLOAT           reduce using rule 3 (global_items -> global_item .)
    DOUBLE          reduce using rule 3 (global_items -> global_item .)
    CHAR            reduce using rule 3 (global_items -> global_item .)
    BOOL            reduce using rule 3 (global_items -> global_item .)
    STRING          reduce using rule 3 (global_items -> global_item .)
    IF              reduce using rule 3 (global_items -> global_item .)
    WHILE           reduce using rule 3 (global_items -> global_item .)
    FOR             reduce using rule 3 (global_items -> global_item .)
    RETURN          reduce using rule 3 (global_items -> global_item .)
    BREAK           reduce using rule 3 (global_items -> global_item .)
    CONTINUE        reduce using rule 3 (global_items -> global_item .)
    LBRACE          reduce using rule 3 (global_items -> global_item .)
    ID              reduce using rule 3 (global_items -> global_item .)
    COUT            reduce using rule 3 (global_items -> global_item .)
    CIN             reduce using rule 3 (global_items -> global_item .)
    $end            reduce using rule 3 (global_items -> global_item .)


state 4

    (4) global_item -> function_def .

    INT             reduce using rule 4 (global_item -> function_def .)
    FLOAT           reduce using rule 4 (global_item -> function_def .)
    DOUBLE          reduce using rule 4 (global_item -> function_def .)
    CHAR            reduce using rule 4 (global_item -> function_def .)
    BOOL            reduce using rule 4 (global_item -> function_def .)
    STRING          reduce using rule 4 (global_item -> function_def .)
    IF              reduce using rule 4 (global_item -> function_def .)
    WHILE           reduce using rule 4 (global_item -> function_def .)
    FOR             reduce using rule 4 (global_item -> function_def .)
    RETURN          reduce using rule 4 (global_item -> function_def .)
    BREAK           reduce using rule 4 (global_item -> function_def .)
    CONTINUE        reduce using rule 4 (global_item -> function_def .)
    LBRACE          reduce using rule 4 (global_item -> function_def .)
    ID              reduce using rule 4 (global_item -> function_def .)
    COUT            reduce using rule 4 (global_item -> function_def .)
    CIN             reduce using rule 4 (global_item -> function_def .)
    $end            reduce using rule 4 (global_item -> function_def .)


state 5

    (5) global_item -> stmt .

    INT             reduce using rule 5 (global_item -> stmt .)
    FLOAT           reduce using rule 5 (global_item -> stmt .)
    DOUBLE          reduce using rule 5 (global_item -> stmt .)
    CHAR            reduce using rule 5 (global_item -> stmt .)
    BOOL            reduce using rule 5 (global_item -> stmt .)
    STRING          reduce using rule 5 (global_item -> stmt .)
    IF              reduce using rule 5 (global_item -> stmt .)
    WHILE           reduce using rule 5 (global_item -> stmt .)
    FOR             reduce using rule 5 (global_item -> stmt .)
    RETURN          reduce using rule 5 (global_item -> stmt .)
    BREAK           reduce using rule 5 (global_item -> stmt .)
    CONTINUE        reduce using rule 5 (global_item -> stmt .)
    LBRACE          reduce using rule 5 (global_item -> stmt .)
    ID              reduce using rule 5 (global_item -> stmt .)
    COUT            reduce using rule 5 (global_item -> stmt .)
    CIN             reduce using rule 5 (global_item -> stmt .)
    $end            reduce using rule 5 (global_item -> stmt .)


state 6

    (6) function_def -> type_specifier . ID LPAREN param_list RPAREN block
    (30) decl_stmt -> type_specifier . init_decl SEMICOLON
    (31) decl_stmt -> type_specifier . ID SEMICOLON
    (32) init_decl -> . ID ASSIGN expression

    ID              shift and go to state 39

    init_decl                      shift and go to state 40

state 7

    (36) assignment -> ID . ASSIGN expression
    (37) unary_inc_dec -> ID . INC
    (38) unary_inc_dec -> ID . DEC
    (39) compound_assignment -> ID . PLUS_ASSIGN expression
    (40) compound_assignment -> ID . MINUS_ASSIGN expression
    (41) compound_assignment -> ID . TIMES_ASSIGN expression
    (42) compound_assignment -> ID . DIVIDE_ASSIGN expression

    ASSIGN          shift and go to state 41
    INC             shift and go to state 42
    DEC             shift and go to state 43
    PLUS_ASSIGN     shift and go to state 44
    MINUS_ASSIGN    shift and go to state 45
    TIMES_ASSIGN    shift and go to state 46
    DIVIDE_ASSIGN   shift and go to state 47


state 8

    (29) stmt -> block .

    INT             reduce using rule 29 (stmt -> block .)
    FLOAT           reduce using rule 29 (stmt -> block .)
    DOUBLE          reduce using rule 29 (stmt -> block .)
    CHAR            reduce using rule 29 (stmt -> block .)
    BOOL            reduce using rule 29 (stmt -> block .)
    STRING          reduce using rule 29 (stmt -> block .)
    IF              reduce using rule 29 (stmt -> block .)
    WHILE           reduce using rule 29 (stmt -> block .)
    FOR             reduce using rule 29 (stmt -> block .)
    RETURN          reduce using rule 29 (stmt -> block .)
    BREAK           reduce using rule 29 (stmt -> block .)
    CONTINUE        reduce using rule 29 (stmt -> block .)
    LBRACE          reduce using rule 29 (stmt -> block .)
    ID              reduce using rule 29 (stmt -> block .)
    COUT            reduce using rule 29 (stmt -> block .)
    CIN             reduce using rule 29 (stmt -> block .)
    $end            reduce using rule 29 (stmt -> block .)
    RBRACE          reduce using rule 29 (stmt -> block .)
    ELSE            reduce using rule 29 (stmt -> block .)


state 9

    (20) stmt -> decl_stmt .

    INT             reduce using rule 20 (stmt -> decl_stmt .)
    FLOAT           reduce using rule 20 (stmt -> decl_stmt .)
    DOUBLE          reduce using rule 20 (stmt -> decl_stmt .)
    CHAR            reduce using rule 20 (stmt -> decl_stmt .)
    BOOL            reduce using rule 20 (stmt -> decl_stmt .)
    STRING          reduce using rule 20 (stmt -> decl_stmt .)
    IF              reduce using rule 20 (stmt -> decl_stmt .)
    WHILE           reduce using rule 20 (stmt -> decl_stmt .)
    FOR             reduce using rule 20 (stmt -> decl_stmt .)
    RETURN          reduce using rule 20 (stmt -> decl_stmt .)
    BREAK           reduce using rule 20 (stmt -> decl_stmt .)
    CONTINUE        reduce using rule 20 (stmt -> decl_stmt .)
    LBRACE          reduce using rule 20 (stmt -> decl_stmt .)
    ID              reduce using rule 20 (stmt -> decl_stmt .)
    COUT            reduce using rule 20 (stmt -> decl_stmt .)
    CIN             reduce using rule 20 (stmt -> decl_stmt .)
    $end            reduce using rule 20 (stmt -> decl_stmt .)
    RBRACE          reduce using rule 20 (stmt -> decl_stmt .)
    ELSE            reduce using rule 20 (stmt -> decl_stmt .)


state 10

    (21) stmt -> expr_stmt .

    INT             reduce using rule 21 (stmt -> expr_stmt .)
    FLOAT           reduce using rule 21 (stmt -> expr_stmt .)
    DOUBLE          reduce using rule 21 (stmt -> expr_stmt .)
    CHAR            reduce using rule 21 (stmt -> expr_stmt .)
    BOOL            reduce using rule 21 (stmt -> expr_stmt .)
    STRING          reduce using rule 21 (stmt -> expr_stmt .)
    IF              reduce using rule 21 (stmt -> expr_stmt .)
    WHILE           reduce using rule 21 (stmt -> expr_stmt .)
    FOR             reduce using rule 21 (stmt -> expr_stmt .)
    RETURN          reduce using rule 21 (stmt -> expr_stmt .)
    BREAK           reduce using rule 21 (stmt -> expr_stmt .)
    CONTINUE        reduce using rule 21 (stmt -> expr_stmt .)
    LBRACE          reduce using rule 21 (stmt -> expr_stmt .)
    ID              reduce using rule 21 (stmt -> expr_stmt .)
    COUT            reduce using rule 21 (stmt -> expr_stmt .)
    CIN             reduce using rule 21 (stmt -> expr_stmt .)
    $end            reduce using rule 21 (stmt -> expr_stmt .)
    RBRACE          reduce using rule 21 (stmt -> expr_stmt .)
    ELSE            reduce using rule 21 (stmt -> expr_stmt .)


state 11

    (22) stmt -> if_stmt .

    INT             reduce using rule 22 (stmt -> if_stmt .)
    FLOAT           reduce using rule 22 (stmt -> if_stmt .)
    DOUBLE          reduce using rule 22 (stmt -> if_stmt .)
    CHAR            reduce using rule 22 (stmt -> if_stmt .)
    BOOL            reduce using rule 22 (stmt -> if_stmt .)
    STRING          reduce using rule 22 (stmt -> if_stmt .)
    IF              reduce using rule 22 (stmt -> if_stmt .)
    WHILE           reduce using rule 22 (stmt -> if_stmt .)
    FOR             reduce using rule 22 (stmt -> if_stmt .)
    RETURN          reduce using rule 22 (stmt -> if_stmt .)
    BREAK           reduce using rule 22 (stmt -> if_stmt .)
    CONTINUE        reduce using rule 22 (stmt -> if_stmt .)
    LBRACE          reduce using rule 22 (stmt -> if_stmt .)
    ID              reduce using rule 22 (stmt -> if_stmt .)
    COUT            reduce using rule 22 (stmt -> if_stmt .)
    CIN             reduce using rule 22 (stmt -> if_stmt .)
    $end            reduce using rule 22 (stmt -> if_stmt .)
    RBRACE          reduce using rule 22 (stmt -> if_stmt .)
    ELSE            reduce using rule 22 (stmt -> if_stmt .)


state 12

    (23) stmt -> while_stmt .

    INT             reduce using rule 23 (stmt -> while_stmt .)
    FLOAT           reduce using rule 23 (stmt -> while_stmt .)
    DOUBLE          reduce using rule 23 (stmt -> while_stmt .)
    CHAR            reduce using rule 23 (stmt -> while_stmt .)
    BOOL            reduce using rule 23 (stmt -> while_stmt .)
    STRING          reduce using rule 23 (stmt -> while_stmt .)
    IF              reduce using rule 23 (stmt -> while_stmt .)
    WHILE           reduce using rule 23 (stmt -> while_stmt .)
    FOR             reduce using rule 23 (stmt -> while_stmt .)
    RETURN          reduce using rule 23 (stmt -> while_stmt .)
    BREAK           reduce using rule 23 (stmt -> while_stmt .)
    CONTINUE        reduce using rule 23 (stmt -> while_stmt .)
    LBRACE          reduce using rule 23 (stmt -> while_stmt .)
    ID              reduce using rule 23 (stmt -> while_stmt .)
    COUT            reduce using rule 23 (stmt -> while_stmt .)
    CIN             reduce using rule 23 (stmt -> while_stmt .)
    $end            reduce using rule 23 (stmt -> while_stmt .)
    RBRACE          reduce using rule 23 (stmt -> while_stmt .)
    ELSE            reduce using rule 23 (stmt -> while_stmt .)


state 13

    (24) stmt -> for_stmt .

    INT             reduce using rule 24 (stmt -> for_stmt .)
    FLOAT           reduce using rule 24 (stmt -> for_stmt .)
    DOUBLE          reduce using rule 24 (stmt -> for_stmt .)
    CHAR            reduce using rule 24 (stmt -> for_stmt .)
    BOOL            reduce using rule 24 (stmt -> for_stmt .)
    STRING          reduce using rule 24 (stmt -> for_stmt .)
    IF              reduce using rule 24 (stmt -> for_stmt .)
    WHILE           reduce using rule 24 (stmt -> for_stmt .)
    FOR             reduce using rule 24 (stmt -> for_stmt .)
    RETURN          reduce using rule 24 (stmt -> for_stmt .)
    BREAK           reduce using rule 24 (stmt -> for_stmt .)
    CONTINUE        reduce using rule 24 (stmt -> for_stmt .)
    LBRACE          reduce using rule 24 (stmt -> for_stmt .)
    ID              reduce using rule 24 (stmt -> for_stmt .)
    COUT            reduce using rule 24 (stmt -> for_stmt .)
    CIN             reduce using rule 24 (stmt -> for_stmt .)
    $end            reduce using rule 24 (stmt -> for_stmt .)
    RBRACE          reduce using rule 24 (stmt -> for_stmt .)
    ELSE            reduce using rule 24 (stmt -> for_stmt .)


state 14

    (25) stmt -> io_stmt .

    INT             reduce using rule 25 (stmt -> io_stmt .)
    FLOAT           reduce using rule 25 (stmt -> io_stmt .)
    DOUBLE          reduce using rule 25 (stmt -> io_stmt .)
    CHAR            reduce using rule 25 (stmt -> io_stmt .)
    BOOL            reduce using rule 25 (stmt -> io_stmt .)
    STRING          reduce using rule 25 (stmt -> io_stmt .)
    IF              reduce using rule 25 (stmt -> io_stmt .)
    WHILE           reduce using rule 25 (stmt -> io_stmt .)
    FOR             reduce using rule 25 (stmt -> io_stmt .)
    RETURN          reduce using rule 25 (stmt -> io_stmt .)
    BREAK           reduce using rule 25 (stmt -> io_stmt .)
    CONTINUE        reduce using rule 25 (stmt -> io_stmt .)
    LBRACE          reduce using rule 25 (stmt -> io_stmt .)
    ID              reduce using rule 25 (stmt -> io_stmt .)
    COUT            reduce using rule 25 (stmt -> io_stmt .)
    CIN             reduce using rule 25 (stmt -> io_stmt .)
    $end            reduce using rule 25 (stmt -> io_stmt .)
    RBRACE          reduce using rule 25 (stmt -> io_stmt .)
    ELSE            reduce using rule 25 (stmt -> io_stmt .)


state 15

    (26) stmt -> return_stmt .

    INT             reduce using rule 26 (stmt -> return_stmt .)
    FLOAT           reduce using rule 26 (stmt -> return_stmt .)
    DOUBLE          reduce using rule 26 (stmt -> return_stmt .)
    CHAR            reduce using rule 26 (stmt -> return_stmt .)
    BOOL            reduce using rule 26 (stmt -> return_stmt .)
    STRING          reduce using rule 26 (stmt -> return_stmt .)
    IF              reduce using rule 26 (stmt -> return_stmt .)
    WHILE           reduce using rule 26 (stmt -> return_stmt .)
    FOR             reduce using rule 26 (stmt -> return_stmt .)
    RETURN          reduce using rule 26 (stmt -> return_stmt .)
    BREAK           reduce using rule 26 (stmt -> return_stmt .)
    CONTINUE        reduce using rule 26 (stmt -> return_stmt .)
    LBRACE          reduce using rule 26 (stmt -> return_stmt .)
    ID              reduce using rule 26 (stmt -> return_stmt .)
    COUT            reduce using rule 26 (stmt -> return_stmt .)
    CIN             reduce using rule 26 (stmt -> return_stmt .)
    $end            reduce using rule 26 (stmt -> return_stmt .)
    RBRACE          reduce using rule 26 (stmt -> return_stmt .)
    ELSE            reduce using rule 26 (stmt -> return_stmt .)


state 16

    (27) stmt -> break_stmt .

    INT             reduce using rule 27 (stmt -> break_stmt .)
    FLOAT           reduce using rule 27 (stmt -> break_stmt .)
    DOUBLE          reduce using rule 27 (stmt -> break_stmt .)
    CHAR            reduce using rule 27 (stmt -> break_stmt .)
    BOOL            reduce using rule 27 (stmt -> break_stmt .)
    STRING          reduce using rule 27 (stmt -> break_stmt .)
    IF              reduce using rule 27 (stmt -> break_stmt .)
    WHILE           reduce using rule 27 (stmt -> break_stmt .)
    FOR             reduce using rule 27 (stmt -> break_stmt .)
    RETURN          reduce using rule 27 (stmt -> break_stmt .)
    BREAK           reduce using rule 27 (stmt -> break_stmt .)
    CONTINUE        reduce using rule 27 (stmt -> break_stmt .)
    LBRACE          reduce using rule 27 (stmt -> break_stmt .)
    ID              reduce using rule 27 (stmt -> break_stmt .)
    COUT            reduce using rule 27 (stmt -> break_stmt .)
    CIN             reduce using rule 27 (stmt -> break_stmt .)
    $end            reduce using rule 27 (stmt -> break_stmt .)
    RBRACE          reduce using rule 27 (stmt -> break_stmt .)
    ELSE            reduce using rule 27 (stmt -> break_stmt .)


state 17

    (28) stmt -> continue_stmt .

    INT             reduce using rule 28 (stmt -> continue_stmt .)
    FLOAT           reduce using rule 28 (stmt -> continue_stmt .)
    DOUBLE          reduce using rule 28 (stmt -> continue_stmt .)
    CHAR            reduce using rule 28 (stmt -> continue_stmt .)
    BOOL            reduce using rule 28 (stmt -> continue_stmt .)
    STRING          reduce using rule 28 (stmt -> continue_stmt .)
    IF              reduce using rule 28 (stmt -> continue_stmt .)
    WHILE           reduce using rule 28 (stmt -> continue_stmt .)
    FOR             reduce using rule 28 (stmt -> continue_stmt .)
    RETURN          reduce using rule 28 (stmt -> continue_stmt .)
    BREAK           reduce using rule 28 (stmt -> continue_stmt .)
    CONTINUE        reduce using rule 28 (stmt -> continue_stmt .)
    LBRACE          reduce using rule 28 (stmt -> continue_stmt .)
    ID              reduce using rule 28 (stmt -> continue_stmt .)
    COUT            reduce using rule 28 (stmt -> continue_stmt .)
    CIN             reduce using rule 28 (stmt -> continue_stmt .)
    $end            reduce using rule 28 (stmt -> continue_stmt .)
    RBRACE          reduce using rule 28 (stmt -> continue_stmt .)
    ELSE            reduce using rule 28 (stmt -> continue_stmt .)


state 18

    (11) type_specifier -> INT .

    ID              reduce using rule 11 (type_specifier -> INT .)


state 19

    (12) type_specifier -> FLOAT .

    ID              reduce using rule 12 (type_specifier -> FLOAT .)


state 20

    (13) type_specifier -> DOUBLE .

    ID              reduce using rule 13 (type_specifier -> DOUBLE .)


state 21

    (14) type_specifier -> CHAR .

    ID              reduce using rule 14 (type_specifier -> CHAR .)


state 22

    (15) type_specifier -> BOOL .

    ID              reduce using rule 15 (type_specifier -> BOOL .)


state 23

    (16) type_specifier -> STRING .

    ID              reduce using rule 16 (type_specifier -> STRING .)


state 24

    (33) expr_stmt -> assignment . SEMICOLON

    SEMICOLON       shift and go to state 48


state 25

    (34) expr_stmt -> unary_inc_dec . SEMICOLON

    SEMICOLON       shift and go to state 49


state 26

    (35) expr_stmt -> compound_assignment . SEMICOLON

    SEMICOLON       shift and go to state 50


state 27

    (92) if_stmt -> IF . LPAREN expression RPAREN stmt ELSE stmt
    (93) if_stmt -> IF . LPAREN expression RPAREN stmt

    LPAREN          shift and go to state 51


state 28

    (64) while_stmt -> WHILE . LPAREN expression RPAREN stmt

    LPAREN          shift and go to state 52


state 29

    (65) for_stmt -> FOR . LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt

    LPAREN          shift and go to state 53


state 30

    (79) io_stmt -> cout_stmt . SEMICOLON

    SEMICOLON       shift and go to state 54


state 31

    (80) io_stmt -> cin_stmt . SEMICOLON

    SEMICOLON       shift and go to state 55


state 32

    (94) return_stmt -> RETURN . expression SEMICOLON
    (95) return_stmt -> RETURN . SEMICOLON
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    SEMICOLON       shift and go to state 57
    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    expression                     shift and go to state 56

state 33

    (96) break_stmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 66


state 34

    (97) continue_stmt -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 67


state 35

    (17) block -> LBRACE . stmt_list RBRACE
    (18) stmt_list -> . stmt_list stmt
    (19) stmt_list -> . empty
    (98) empty -> .

    RBRACE          reduce using rule 98 (empty -> .)
    IF              reduce using rule 98 (empty -> .)
    WHILE           reduce using rule 98 (empty -> .)
    FOR             reduce using rule 98 (empty -> .)
    RETURN          reduce using rule 98 (empty -> .)
    BREAK           reduce using rule 98 (empty -> .)
    CONTINUE        reduce using rule 98 (empty -> .)
    LBRACE          reduce using rule 98 (empty -> .)
    INT             reduce using rule 98 (empty -> .)
    FLOAT           reduce using rule 98 (empty -> .)
    DOUBLE          reduce using rule 98 (empty -> .)
    CHAR            reduce using rule 98 (empty -> .)
    BOOL            reduce using rule 98 (empty -> .)
    STRING          reduce using rule 98 (empty -> .)
    ID              reduce using rule 98 (empty -> .)
    COUT            reduce using rule 98 (empty -> .)
    CIN             reduce using rule 98 (empty -> .)

    stmt_list                      shift and go to state 68
    empty                          shift and go to state 69

state 36

    (81) cout_stmt -> COUT . insertion_list
    (82) insertion_list -> . LSHIFT insertion_items

    LSHIFT          shift and go to state 71

    insertion_list                 shift and go to state 70

state 37

    (87) cin_stmt -> CIN . extraction_list
    (88) extraction_list -> . RSHIFT extraction_items

    RSHIFT          shift and go to state 73

    extraction_list                shift and go to state 72

state 38

    (2) global_items -> global_items global_item .

    INT             reduce using rule 2 (global_items -> global_items global_item .)
    FLOAT           reduce using rule 2 (global_items -> global_items global_item .)
    DOUBLE          reduce using rule 2 (global_items -> global_items global_item .)
    CHAR            reduce using rule 2 (global_items -> global_items global_item .)
    BOOL            reduce using rule 2 (global_items -> global_items global_item .)
    STRING          reduce using rule 2 (global_items -> global_items global_item .)
    IF              reduce using rule 2 (global_items -> global_items global_item .)
    WHILE           reduce using rule 2 (global_items -> global_items global_item .)
    FOR             reduce using rule 2 (global_items -> global_items global_item .)
    RETURN          reduce using rule 2 (global_items -> global_items global_item .)
    BREAK           reduce using rule 2 (global_items -> global_items global_item .)
    CONTINUE        reduce using rule 2 (global_items -> global_items global_item .)
    LBRACE          reduce using rule 2 (global_items -> global_items global_item .)
    ID              reduce using rule 2 (global_items -> global_items global_item .)
    COUT            reduce using rule 2 (global_items -> global_items global_item .)
    CIN             reduce using rule 2 (global_items -> global_items global_item .)
    $end            reduce using rule 2 (global_items -> global_items global_item .)


state 39

    (6) function_def -> type_specifier ID . LPAREN param_list RPAREN block
    (31) decl_stmt -> type_specifier ID . SEMICOLON
    (32) init_decl -> ID . ASSIGN expression

    LPAREN          shift and go to state 74
    SEMICOLON       shift and go to state 75
    ASSIGN          shift and go to state 76


state 40

    (30) decl_stmt -> type_specifier init_decl . SEMICOLON

    SEMICOLON       shift and go to state 77


state 41

    (36) assignment -> ID ASSIGN . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    expression                     shift and go to state 78

state 42

    (37) unary_inc_dec -> ID INC .

    SEMICOLON       reduce using rule 37 (unary_inc_dec -> ID INC .)


state 43

    (38) unary_inc_dec -> ID DEC .

    SEMICOLON       reduce using rule 38 (unary_inc_dec -> ID DEC .)


state 44

    (39) compound_assignment -> ID PLUS_ASSIGN . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    expression                     shift and go to state 79

state 45

    (40) compound_assignment -> ID MINUS_ASSIGN . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    expression                     shift and go to state 80

state 46

    (41) compound_assignment -> ID TIMES_ASSIGN . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    expression                     shift and go to state 81

state 47

    (42) compound_assignment -> ID DIVIDE_ASSIGN . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    expression                     shift and go to state 82

state 48

    (33) expr_stmt -> assignment SEMICOLON .

    INT             reduce using rule 33 (expr_stmt -> assignment SEMICOLON .)
    FLOAT           reduce using rule 33 (expr_stmt -> assignment SEMICOLON .)
    DOUBLE          reduce using rule 33 (expr_stmt -> assignment SEMICOLON .)
    CHAR            reduce using rule 33 (expr_stmt -> assignment SEMICOLON .)
    BOOL            reduce using rule 33 (expr_stmt -> assignment SEMICOLON .)
    STRING          reduce using rule 33 (expr_stmt -> assignment SEMICOLON .)
    IF              reduce using rule 33 (expr_stmt -> assignment SEMICOLON .)
    WHILE           reduce using rule 33 (expr_stmt -> assignment SEMICOLON .)
    FOR             reduce using rule 33 (expr_stmt -> assignment SEMICOLON .)
    RETURN          reduce using rule 33 (expr_stmt -> assignment SEMICOLON .)
    BREAK           reduce using rule 33 (expr_stmt -> assignment SEMICOLON .)
    CONTINUE        reduce using rule 33 (expr_stmt -> assignment SEMICOLON .)
    LBRACE          reduce using rule 33 (expr_stmt -> assignment SEMICOLON .)
    ID              reduce using rule 33 (expr_stmt -> assignment SEMICOLON .)
    COUT            reduce using rule 33 (expr_stmt -> assignment SEMICOLON .)
    CIN             reduce using rule 33 (expr_stmt -> assignment SEMICOLON .)
    $end            reduce using rule 33 (expr_stmt -> assignment SEMICOLON .)
    RBRACE          reduce using rule 33 (expr_stmt -> assignment SEMICOLON .)
    ELSE            reduce using rule 33 (expr_stmt -> assignment SEMICOLON .)


state 49

    (34) expr_stmt -> unary_inc_dec SEMICOLON .

    INT             reduce using rule 34 (expr_stmt -> unary_inc_dec SEMICOLON .)
    FLOAT           reduce using rule 34 (expr_stmt -> unary_inc_dec SEMICOLON .)
    DOUBLE          reduce using rule 34 (expr_stmt -> unary_inc_dec SEMICOLON .)
    CHAR            reduce using rule 34 (expr_stmt -> unary_inc_dec SEMICOLON .)
    BOOL            reduce using rule 34 (expr_stmt -> unary_inc_dec SEMICOLON .)
    STRING          reduce using rule 34 (expr_stmt -> unary_inc_dec SEMICOLON .)
    IF              reduce using rule 34 (expr_stmt -> unary_inc_dec SEMICOLON .)
    WHILE           reduce using rule 34 (expr_stmt -> unary_inc_dec SEMICOLON .)
    FOR             reduce using rule 34 (expr_stmt -> unary_inc_dec SEMICOLON .)
    RETURN          reduce using rule 34 (expr_stmt -> unary_inc_dec SEMICOLON .)
    BREAK           reduce using rule 34 (expr_stmt -> unary_inc_dec SEMICOLON .)
    CONTINUE        reduce using rule 34 (expr_stmt -> unary_inc_dec SEMICOLON .)
    LBRACE          reduce using rule 34 (expr_stmt -> unary_inc_dec SEMICOLON .)
    ID              reduce using rule 34 (expr_stmt -> unary_inc_dec SEMICOLON .)
    COUT            reduce using rule 34 (expr_stmt -> unary_inc_dec SEMICOLON .)
    CIN             reduce using rule 34 (expr_stmt -> unary_inc_dec SEMICOLON .)
    $end            reduce using rule 34 (expr_stmt -> unary_inc_dec SEMICOLON .)
    RBRACE          reduce using rule 34 (expr_stmt -> unary_inc_dec SEMICOLON .)
    ELSE            reduce using rule 34 (expr_stmt -> unary_inc_dec SEMICOLON .)


state 50

    (35) expr_stmt -> compound_assignment SEMICOLON .

    INT             reduce using rule 35 (expr_stmt -> compound_assignment SEMICOLON .)
    FLOAT           reduce using rule 35 (expr_stmt -> compound_assignment SEMICOLON .)
    DOUBLE          reduce using rule 35 (expr_stmt -> compound_assignment SEMICOLON .)
    CHAR            reduce using rule 35 (expr_stmt -> compound_assignment SEMICOLON .)
    BOOL            reduce using rule 35 (expr_stmt -> compound_assignment SEMICOLON .)
    STRING          reduce using rule 35 (expr_stmt -> compound_assignment SEMICOLON .)
    IF              reduce using rule 35 (expr_stmt -> compound_assignment SEMICOLON .)
    WHILE           reduce using rule 35 (expr_stmt -> compound_assignment SEMICOLON .)
    FOR             reduce using rule 35 (expr_stmt -> compound_assignment SEMICOLON .)
    RETURN          reduce using rule 35 (expr_stmt -> compound_assignment SEMICOLON .)
    BREAK           reduce using rule 35 (expr_stmt -> compound_assignment SEMICOLON .)
    CONTINUE        reduce using rule 35 (expr_stmt -> compound_assignment SEMICOLON .)
    LBRACE          reduce using rule 35 (expr_stmt -> compound_assignment SEMICOLON .)
    ID              reduce using rule 35 (expr_stmt -> compound_assignment SEMICOLON .)
    COUT            reduce using rule 35 (expr_stmt -> compound_assignment SEMICOLON .)
    CIN             reduce using rule 35 (expr_stmt -> compound_assignment SEMICOLON .)
    $end            reduce using rule 35 (expr_stmt -> compound_assignment SEMICOLON .)
    RBRACE          reduce using rule 35 (expr_stmt -> compound_assignment SEMICOLON .)
    ELSE            reduce using rule 35 (expr_stmt -> compound_assignment SEMICOLON .)


state 51

    (92) if_stmt -> IF LPAREN . expression RPAREN stmt ELSE stmt
    (93) if_stmt -> IF LPAREN . expression RPAREN stmt
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    expression                     shift and go to state 83

state 52

    (64) while_stmt -> WHILE LPAREN . expression RPAREN stmt
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    expression                     shift and go to state 84

state 53

    (65) for_stmt -> FOR LPAREN . for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt
    (66) for_init -> . decl_stmt
    (67) for_init -> . assignment
    (68) for_init -> . unary_inc_dec
    (69) for_init -> . compound_assignment
    (70) for_init -> . empty
    (30) decl_stmt -> . type_specifier init_decl SEMICOLON
    (31) decl_stmt -> . type_specifier ID SEMICOLON
    (36) assignment -> . ID ASSIGN expression
    (37) unary_inc_dec -> . ID INC
    (38) unary_inc_dec -> . ID DEC
    (39) compound_assignment -> . ID PLUS_ASSIGN expression
    (40) compound_assignment -> . ID MINUS_ASSIGN expression
    (41) compound_assignment -> . ID TIMES_ASSIGN expression
    (42) compound_assignment -> . ID DIVIDE_ASSIGN expression
    (98) empty -> .
    (11) type_specifier -> . INT
    (12) type_specifier -> . FLOAT
    (13) type_specifier -> . DOUBLE
    (14) type_specifier -> . CHAR
    (15) type_specifier -> . BOOL
    (16) type_specifier -> . STRING

    ID              shift and go to state 7
    SEMICOLON       reduce using rule 98 (empty -> .)
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    DOUBLE          shift and go to state 20
    CHAR            shift and go to state 21
    BOOL            shift and go to state 22
    STRING          shift and go to state 23

    for_init                       shift and go to state 85
    decl_stmt                      shift and go to state 86
    assignment                     shift and go to state 87
    unary_inc_dec                  shift and go to state 88
    compound_assignment            shift and go to state 89
    empty                          shift and go to state 90
    type_specifier                 shift and go to state 91

state 54

    (79) io_stmt -> cout_stmt SEMICOLON .

    INT             reduce using rule 79 (io_stmt -> cout_stmt SEMICOLON .)
    FLOAT           reduce using rule 79 (io_stmt -> cout_stmt SEMICOLON .)
    DOUBLE          reduce using rule 79 (io_stmt -> cout_stmt SEMICOLON .)
    CHAR            reduce using rule 79 (io_stmt -> cout_stmt SEMICOLON .)
    BOOL            reduce using rule 79 (io_stmt -> cout_stmt SEMICOLON .)
    STRING          reduce using rule 79 (io_stmt -> cout_stmt SEMICOLON .)
    IF              reduce using rule 79 (io_stmt -> cout_stmt SEMICOLON .)
    WHILE           reduce using rule 79 (io_stmt -> cout_stmt SEMICOLON .)
    FOR             reduce using rule 79 (io_stmt -> cout_stmt SEMICOLON .)
    RETURN          reduce using rule 79 (io_stmt -> cout_stmt SEMICOLON .)
    BREAK           reduce using rule 79 (io_stmt -> cout_stmt SEMICOLON .)
    CONTINUE        reduce using rule 79 (io_stmt -> cout_stmt SEMICOLON .)
    LBRACE          reduce using rule 79 (io_stmt -> cout_stmt SEMICOLON .)
    ID              reduce using rule 79 (io_stmt -> cout_stmt SEMICOLON .)
    COUT            reduce using rule 79 (io_stmt -> cout_stmt SEMICOLON .)
    CIN             reduce using rule 79 (io_stmt -> cout_stmt SEMICOLON .)
    $end            reduce using rule 79 (io_stmt -> cout_stmt SEMICOLON .)
    RBRACE          reduce using rule 79 (io_stmt -> cout_stmt SEMICOLON .)
    ELSE            reduce using rule 79 (io_stmt -> cout_stmt SEMICOLON .)


state 55

    (80) io_stmt -> cin_stmt SEMICOLON .

    INT             reduce using rule 80 (io_stmt -> cin_stmt SEMICOLON .)
    FLOAT           reduce using rule 80 (io_stmt -> cin_stmt SEMICOLON .)
    DOUBLE          reduce using rule 80 (io_stmt -> cin_stmt SEMICOLON .)
    CHAR            reduce using rule 80 (io_stmt -> cin_stmt SEMICOLON .)
    BOOL            reduce using rule 80 (io_stmt -> cin_stmt SEMICOLON .)
    STRING          reduce using rule 80 (io_stmt -> cin_stmt SEMICOLON .)
    IF              reduce using rule 80 (io_stmt -> cin_stmt SEMICOLON .)
    WHILE           reduce using rule 80 (io_stmt -> cin_stmt SEMICOLON .)
    FOR             reduce using rule 80 (io_stmt -> cin_stmt SEMICOLON .)
    RETURN          reduce using rule 80 (io_stmt -> cin_stmt SEMICOLON .)
    BREAK           reduce using rule 80 (io_stmt -> cin_stmt SEMICOLON .)
    CONTINUE        reduce using rule 80 (io_stmt -> cin_stmt SEMICOLON .)
    LBRACE          reduce using rule 80 (io_stmt -> cin_stmt SEMICOLON .)
    ID              reduce using rule 80 (io_stmt -> cin_stmt SEMICOLON .)
    COUT            reduce using rule 80 (io_stmt -> cin_stmt SEMICOLON .)
    CIN             reduce using rule 80 (io_stmt -> cin_stmt SEMICOLON .)
    $end            reduce using rule 80 (io_stmt -> cin_stmt SEMICOLON .)
    RBRACE          reduce using rule 80 (io_stmt -> cin_stmt SEMICOLON .)
    ELSE            reduce using rule 80 (io_stmt -> cin_stmt SEMICOLON .)


state 56

    (94) return_stmt -> RETURN expression . SEMICOLON
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    SEMICOLON       shift and go to state 92
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 96
    MOD             shift and go to state 97
    EQ              shift and go to state 98
    NEQ             shift and go to state 99
    LT              shift and go to state 100
    GT              shift and go to state 101
    LE              shift and go to state 102
    GE              shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105


state 57

    (95) return_stmt -> RETURN SEMICOLON .

    INT             reduce using rule 95 (return_stmt -> RETURN SEMICOLON .)
    FLOAT           reduce using rule 95 (return_stmt -> RETURN SEMICOLON .)
    DOUBLE          reduce using rule 95 (return_stmt -> RETURN SEMICOLON .)
    CHAR            reduce using rule 95 (return_stmt -> RETURN SEMICOLON .)
    BOOL            reduce using rule 95 (return_stmt -> RETURN SEMICOLON .)
    STRING          reduce using rule 95 (return_stmt -> RETURN SEMICOLON .)
    IF              reduce using rule 95 (return_stmt -> RETURN SEMICOLON .)
    WHILE           reduce using rule 95 (return_stmt -> RETURN SEMICOLON .)
    FOR             reduce using rule 95 (return_stmt -> RETURN SEMICOLON .)
    RETURN          reduce using rule 95 (return_stmt -> RETURN SEMICOLON .)
    BREAK           reduce using rule 95 (return_stmt -> RETURN SEMICOLON .)
    CONTINUE        reduce using rule 95 (return_stmt -> RETURN SEMICOLON .)
    LBRACE          reduce using rule 95 (return_stmt -> RETURN SEMICOLON .)
    ID              reduce using rule 95 (return_stmt -> RETURN SEMICOLON .)
    COUT            reduce using rule 95 (return_stmt -> RETURN SEMICOLON .)
    CIN             reduce using rule 95 (return_stmt -> RETURN SEMICOLON .)
    $end            reduce using rule 95 (return_stmt -> RETURN SEMICOLON .)
    RBRACE          reduce using rule 95 (return_stmt -> RETURN SEMICOLON .)
    ELSE            reduce using rule 95 (return_stmt -> RETURN SEMICOLON .)


state 58

    (56) expression -> MINUS . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    expression                     shift and go to state 106

state 59

    (57) expression -> NOT . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    expression                     shift and go to state 107

state 60

    (58) expression -> LPAREN . expression RPAREN
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    expression                     shift and go to state 108

state 61

    (59) expression -> INT_CONST .

    SEMICOLON       reduce using rule 59 (expression -> INT_CONST .)
    PLUS            reduce using rule 59 (expression -> INT_CONST .)
    MINUS           reduce using rule 59 (expression -> INT_CONST .)
    TIMES           reduce using rule 59 (expression -> INT_CONST .)
    DIVIDE          reduce using rule 59 (expression -> INT_CONST .)
    MOD             reduce using rule 59 (expression -> INT_CONST .)
    EQ              reduce using rule 59 (expression -> INT_CONST .)
    NEQ             reduce using rule 59 (expression -> INT_CONST .)
    LT              reduce using rule 59 (expression -> INT_CONST .)
    GT              reduce using rule 59 (expression -> INT_CONST .)
    LE              reduce using rule 59 (expression -> INT_CONST .)
    GE              reduce using rule 59 (expression -> INT_CONST .)
    AND             reduce using rule 59 (expression -> INT_CONST .)
    OR              reduce using rule 59 (expression -> INT_CONST .)
    RPAREN          reduce using rule 59 (expression -> INT_CONST .)
    LSHIFT          reduce using rule 59 (expression -> INT_CONST .)


state 62

    (60) expression -> FLOAT_CONST .

    SEMICOLON       reduce using rule 60 (expression -> FLOAT_CONST .)
    PLUS            reduce using rule 60 (expression -> FLOAT_CONST .)
    MINUS           reduce using rule 60 (expression -> FLOAT_CONST .)
    TIMES           reduce using rule 60 (expression -> FLOAT_CONST .)
    DIVIDE          reduce using rule 60 (expression -> FLOAT_CONST .)
    MOD             reduce using rule 60 (expression -> FLOAT_CONST .)
    EQ              reduce using rule 60 (expression -> FLOAT_CONST .)
    NEQ             reduce using rule 60 (expression -> FLOAT_CONST .)
    LT              reduce using rule 60 (expression -> FLOAT_CONST .)
    GT              reduce using rule 60 (expression -> FLOAT_CONST .)
    LE              reduce using rule 60 (expression -> FLOAT_CONST .)
    GE              reduce using rule 60 (expression -> FLOAT_CONST .)
    AND             reduce using rule 60 (expression -> FLOAT_CONST .)
    OR              reduce using rule 60 (expression -> FLOAT_CONST .)
    RPAREN          reduce using rule 60 (expression -> FLOAT_CONST .)
    LSHIFT          reduce using rule 60 (expression -> FLOAT_CONST .)


state 63

    (61) expression -> STRING_LITERAL .

    SEMICOLON       reduce using rule 61 (expression -> STRING_LITERAL .)
    PLUS            reduce using rule 61 (expression -> STRING_LITERAL .)
    MINUS           reduce using rule 61 (expression -> STRING_LITERAL .)
    TIMES           reduce using rule 61 (expression -> STRING_LITERAL .)
    DIVIDE          reduce using rule 61 (expression -> STRING_LITERAL .)
    MOD             reduce using rule 61 (expression -> STRING_LITERAL .)
    EQ              reduce using rule 61 (expression -> STRING_LITERAL .)
    NEQ             reduce using rule 61 (expression -> STRING_LITERAL .)
    LT              reduce using rule 61 (expression -> STRING_LITERAL .)
    GT              reduce using rule 61 (expression -> STRING_LITERAL .)
    LE              reduce using rule 61 (expression -> STRING_LITERAL .)
    GE              reduce using rule 61 (expression -> STRING_LITERAL .)
    AND             reduce using rule 61 (expression -> STRING_LITERAL .)
    OR              reduce using rule 61 (expression -> STRING_LITERAL .)
    RPAREN          reduce using rule 61 (expression -> STRING_LITERAL .)
    LSHIFT          reduce using rule 61 (expression -> STRING_LITERAL .)


state 64

    (62) expression -> CHAR_CONST .

    SEMICOLON       reduce using rule 62 (expression -> CHAR_CONST .)
    PLUS            reduce using rule 62 (expression -> CHAR_CONST .)
    MINUS           reduce using rule 62 (expression -> CHAR_CONST .)
    TIMES           reduce using rule 62 (expression -> CHAR_CONST .)
    DIVIDE          reduce using rule 62 (expression -> CHAR_CONST .)
    MOD             reduce using rule 62 (expression -> CHAR_CONST .)
    EQ              reduce using rule 62 (expression -> CHAR_CONST .)
    NEQ             reduce using rule 62 (expression -> CHAR_CONST .)
    LT              reduce using rule 62 (expression -> CHAR_CONST .)
    GT              reduce using rule 62 (expression -> CHAR_CONST .)
    LE              reduce using rule 62 (expression -> CHAR_CONST .)
    GE              reduce using rule 62 (expression -> CHAR_CONST .)
    AND             reduce using rule 62 (expression -> CHAR_CONST .)
    OR              reduce using rule 62 (expression -> CHAR_CONST .)
    RPAREN          reduce using rule 62 (expression -> CHAR_CONST .)
    LSHIFT          reduce using rule 62 (expression -> CHAR_CONST .)


state 65

    (63) expression -> ID .

    SEMICOLON       reduce using rule 63 (expression -> ID .)
    PLUS            reduce using rule 63 (expression -> ID .)
    MINUS           reduce using rule 63 (expression -> ID .)
    TIMES           reduce using rule 63 (expression -> ID .)
    DIVIDE          reduce using rule 63 (expression -> ID .)
    MOD             reduce using rule 63 (expression -> ID .)
    EQ              reduce using rule 63 (expression -> ID .)
    NEQ             reduce using rule 63 (expression -> ID .)
    LT              reduce using rule 63 (expression -> ID .)
    GT              reduce using rule 63 (expression -> ID .)
    LE              reduce using rule 63 (expression -> ID .)
    GE              reduce using rule 63 (expression -> ID .)
    AND             reduce using rule 63 (expression -> ID .)
    OR              reduce using rule 63 (expression -> ID .)
    RPAREN          reduce using rule 63 (expression -> ID .)
    LSHIFT          reduce using rule 63 (expression -> ID .)


state 66

    (96) break_stmt -> BREAK SEMICOLON .

    INT             reduce using rule 96 (break_stmt -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 96 (break_stmt -> BREAK SEMICOLON .)
    DOUBLE          reduce using rule 96 (break_stmt -> BREAK SEMICOLON .)
    CHAR            reduce using rule 96 (break_stmt -> BREAK SEMICOLON .)
    BOOL            reduce using rule 96 (break_stmt -> BREAK SEMICOLON .)
    STRING          reduce using rule 96 (break_stmt -> BREAK SEMICOLON .)
    IF              reduce using rule 96 (break_stmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 96 (break_stmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 96 (break_stmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 96 (break_stmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 96 (break_stmt -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 96 (break_stmt -> BREAK SEMICOLON .)
    LBRACE          reduce using rule 96 (break_stmt -> BREAK SEMICOLON .)
    ID              reduce using rule 96 (break_stmt -> BREAK SEMICOLON .)
    COUT            reduce using rule 96 (break_stmt -> BREAK SEMICOLON .)
    CIN             reduce using rule 96 (break_stmt -> BREAK SEMICOLON .)
    $end            reduce using rule 96 (break_stmt -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 96 (break_stmt -> BREAK SEMICOLON .)
    ELSE            reduce using rule 96 (break_stmt -> BREAK SEMICOLON .)


state 67

    (97) continue_stmt -> CONTINUE SEMICOLON .

    INT             reduce using rule 97 (continue_stmt -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 97 (continue_stmt -> CONTINUE SEMICOLON .)
    DOUBLE          reduce using rule 97 (continue_stmt -> CONTINUE SEMICOLON .)
    CHAR            reduce using rule 97 (continue_stmt -> CONTINUE SEMICOLON .)
    BOOL            reduce using rule 97 (continue_stmt -> CONTINUE SEMICOLON .)
    STRING          reduce using rule 97 (continue_stmt -> CONTINUE SEMICOLON .)
    IF              reduce using rule 97 (continue_stmt -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 97 (continue_stmt -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 97 (continue_stmt -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 97 (continue_stmt -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 97 (continue_stmt -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 97 (continue_stmt -> CONTINUE SEMICOLON .)
    LBRACE          reduce using rule 97 (continue_stmt -> CONTINUE SEMICOLON .)
    ID              reduce using rule 97 (continue_stmt -> CONTINUE SEMICOLON .)
    COUT            reduce using rule 97 (continue_stmt -> CONTINUE SEMICOLON .)
    CIN             reduce using rule 97 (continue_stmt -> CONTINUE SEMICOLON .)
    $end            reduce using rule 97 (continue_stmt -> CONTINUE SEMICOLON .)
    RBRACE          reduce using rule 97 (continue_stmt -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 97 (continue_stmt -> CONTINUE SEMICOLON .)


state 68

    (17) block -> LBRACE stmt_list . RBRACE
    (18) stmt_list -> stmt_list . stmt
    (20) stmt -> . decl_stmt
    (21) stmt -> . expr_stmt
    (22) stmt -> . if_stmt
    (23) stmt -> . while_stmt
    (24) stmt -> . for_stmt
    (25) stmt -> . io_stmt
    (26) stmt -> . return_stmt
    (27) stmt -> . break_stmt
    (28) stmt -> . continue_stmt
    (29) stmt -> . block
    (30) decl_stmt -> . type_specifier init_decl SEMICOLON
    (31) decl_stmt -> . type_specifier ID SEMICOLON
    (33) expr_stmt -> . assignment SEMICOLON
    (34) expr_stmt -> . unary_inc_dec SEMICOLON
    (35) expr_stmt -> . compound_assignment SEMICOLON
    (92) if_stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (93) if_stmt -> . IF LPAREN expression RPAREN stmt
    (64) while_stmt -> . WHILE LPAREN expression RPAREN stmt
    (65) for_stmt -> . FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt
    (79) io_stmt -> . cout_stmt SEMICOLON
    (80) io_stmt -> . cin_stmt SEMICOLON
    (94) return_stmt -> . RETURN expression SEMICOLON
    (95) return_stmt -> . RETURN SEMICOLON
    (96) break_stmt -> . BREAK SEMICOLON
    (97) continue_stmt -> . CONTINUE SEMICOLON
    (17) block -> . LBRACE stmt_list RBRACE
    (11) type_specifier -> . INT
    (12) type_specifier -> . FLOAT
    (13) type_specifier -> . DOUBLE
    (14) type_specifier -> . CHAR
    (15) type_specifier -> . BOOL
    (16) type_specifier -> . STRING
    (36) assignment -> . ID ASSIGN expression
    (37) unary_inc_dec -> . ID INC
    (38) unary_inc_dec -> . ID DEC
    (39) compound_assignment -> . ID PLUS_ASSIGN expression
    (40) compound_assignment -> . ID MINUS_ASSIGN expression
    (41) compound_assignment -> . ID TIMES_ASSIGN expression
    (42) compound_assignment -> . ID DIVIDE_ASSIGN expression
    (81) cout_stmt -> . COUT insertion_list
    (87) cin_stmt -> . CIN extraction_list

    RBRACE          shift and go to state 109
    IF              shift and go to state 27
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    LBRACE          shift and go to state 35
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    DOUBLE          shift and go to state 20
    CHAR            shift and go to state 21
    BOOL            shift and go to state 22
    STRING          shift and go to state 23
    ID              shift and go to state 7
    COUT            shift and go to state 36
    CIN             shift and go to state 37

    stmt                           shift and go to state 110
    decl_stmt                      shift and go to state 9
    expr_stmt                      shift and go to state 10
    if_stmt                        shift and go to state 11
    while_stmt                     shift and go to state 12
    for_stmt                       shift and go to state 13
    io_stmt                        shift and go to state 14
    return_stmt                    shift and go to state 15
    break_stmt                     shift and go to state 16
    continue_stmt                  shift and go to state 17
    block                          shift and go to state 8
    type_specifier                 shift and go to state 91
    assignment                     shift and go to state 24
    unary_inc_dec                  shift and go to state 25
    compound_assignment            shift and go to state 26
    cout_stmt                      shift and go to state 30
    cin_stmt                       shift and go to state 31

state 69

    (19) stmt_list -> empty .

    RBRACE          reduce using rule 19 (stmt_list -> empty .)
    IF              reduce using rule 19 (stmt_list -> empty .)
    WHILE           reduce using rule 19 (stmt_list -> empty .)
    FOR             reduce using rule 19 (stmt_list -> empty .)
    RETURN          reduce using rule 19 (stmt_list -> empty .)
    BREAK           reduce using rule 19 (stmt_list -> empty .)
    CONTINUE        reduce using rule 19 (stmt_list -> empty .)
    LBRACE          reduce using rule 19 (stmt_list -> empty .)
    INT             reduce using rule 19 (stmt_list -> empty .)
    FLOAT           reduce using rule 19 (stmt_list -> empty .)
    DOUBLE          reduce using rule 19 (stmt_list -> empty .)
    CHAR            reduce using rule 19 (stmt_list -> empty .)
    BOOL            reduce using rule 19 (stmt_list -> empty .)
    STRING          reduce using rule 19 (stmt_list -> empty .)
    ID              reduce using rule 19 (stmt_list -> empty .)
    COUT            reduce using rule 19 (stmt_list -> empty .)
    CIN             reduce using rule 19 (stmt_list -> empty .)


state 70

    (81) cout_stmt -> COUT insertion_list .

    SEMICOLON       reduce using rule 81 (cout_stmt -> COUT insertion_list .)


state 71

    (82) insertion_list -> LSHIFT . insertion_items
    (83) insertion_items -> . insertion_items LSHIFT insertion_item
    (84) insertion_items -> . insertion_item
    (85) insertion_item -> . expression
    (86) insertion_item -> . ENDL
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    ENDL            shift and go to state 114
    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    insertion_items                shift and go to state 111
    insertion_item                 shift and go to state 112
    expression                     shift and go to state 113

state 72

    (87) cin_stmt -> CIN extraction_list .

    SEMICOLON       reduce using rule 87 (cin_stmt -> CIN extraction_list .)


state 73

    (88) extraction_list -> RSHIFT . extraction_items
    (89) extraction_items -> . extraction_items RSHIFT extraction_target
    (90) extraction_items -> . extraction_target
    (91) extraction_target -> . ID

    ID              shift and go to state 117

    extraction_items               shift and go to state 115
    extraction_target              shift and go to state 116

state 74

    (6) function_def -> type_specifier ID LPAREN . param_list RPAREN block
    (7) param_list -> . param_list COMMA param
    (8) param_list -> . param
    (9) param_list -> . empty
    (10) param -> . type_specifier ID
    (98) empty -> .
    (11) type_specifier -> . INT
    (12) type_specifier -> . FLOAT
    (13) type_specifier -> . DOUBLE
    (14) type_specifier -> . CHAR
    (15) type_specifier -> . BOOL
    (16) type_specifier -> . STRING

    RPAREN          reduce using rule 98 (empty -> .)
    COMMA           reduce using rule 98 (empty -> .)
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    DOUBLE          shift and go to state 20
    CHAR            shift and go to state 21
    BOOL            shift and go to state 22
    STRING          shift and go to state 23

    type_specifier                 shift and go to state 118
    param_list                     shift and go to state 119
    param                          shift and go to state 120
    empty                          shift and go to state 121

state 75

    (31) decl_stmt -> type_specifier ID SEMICOLON .

    INT             reduce using rule 31 (decl_stmt -> type_specifier ID SEMICOLON .)
    FLOAT           reduce using rule 31 (decl_stmt -> type_specifier ID SEMICOLON .)
    DOUBLE          reduce using rule 31 (decl_stmt -> type_specifier ID SEMICOLON .)
    CHAR            reduce using rule 31 (decl_stmt -> type_specifier ID SEMICOLON .)
    BOOL            reduce using rule 31 (decl_stmt -> type_specifier ID SEMICOLON .)
    STRING          reduce using rule 31 (decl_stmt -> type_specifier ID SEMICOLON .)
    IF              reduce using rule 31 (decl_stmt -> type_specifier ID SEMICOLON .)
    WHILE           reduce using rule 31 (decl_stmt -> type_specifier ID SEMICOLON .)
    FOR             reduce using rule 31 (decl_stmt -> type_specifier ID SEMICOLON .)
    RETURN          reduce using rule 31 (decl_stmt -> type_specifier ID SEMICOLON .)
    BREAK           reduce using rule 31 (decl_stmt -> type_specifier ID SEMICOLON .)
    CONTINUE        reduce using rule 31 (decl_stmt -> type_specifier ID SEMICOLON .)
    LBRACE          reduce using rule 31 (decl_stmt -> type_specifier ID SEMICOLON .)
    ID              reduce using rule 31 (decl_stmt -> type_specifier ID SEMICOLON .)
    COUT            reduce using rule 31 (decl_stmt -> type_specifier ID SEMICOLON .)
    CIN             reduce using rule 31 (decl_stmt -> type_specifier ID SEMICOLON .)
    $end            reduce using rule 31 (decl_stmt -> type_specifier ID SEMICOLON .)
    SEMICOLON       reduce using rule 31 (decl_stmt -> type_specifier ID SEMICOLON .)
    RBRACE          reduce using rule 31 (decl_stmt -> type_specifier ID SEMICOLON .)
    ELSE            reduce using rule 31 (decl_stmt -> type_specifier ID SEMICOLON .)


state 76

    (32) init_decl -> ID ASSIGN . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    expression                     shift and go to state 122

state 77

    (30) decl_stmt -> type_specifier init_decl SEMICOLON .

    INT             reduce using rule 30 (decl_stmt -> type_specifier init_decl SEMICOLON .)
    FLOAT           reduce using rule 30 (decl_stmt -> type_specifier init_decl SEMICOLON .)
    DOUBLE          reduce using rule 30 (decl_stmt -> type_specifier init_decl SEMICOLON .)
    CHAR            reduce using rule 30 (decl_stmt -> type_specifier init_decl SEMICOLON .)
    BOOL            reduce using rule 30 (decl_stmt -> type_specifier init_decl SEMICOLON .)
    STRING          reduce using rule 30 (decl_stmt -> type_specifier init_decl SEMICOLON .)
    IF              reduce using rule 30 (decl_stmt -> type_specifier init_decl SEMICOLON .)
    WHILE           reduce using rule 30 (decl_stmt -> type_specifier init_decl SEMICOLON .)
    FOR             reduce using rule 30 (decl_stmt -> type_specifier init_decl SEMICOLON .)
    RETURN          reduce using rule 30 (decl_stmt -> type_specifier init_decl SEMICOLON .)
    BREAK           reduce using rule 30 (decl_stmt -> type_specifier init_decl SEMICOLON .)
    CONTINUE        reduce using rule 30 (decl_stmt -> type_specifier init_decl SEMICOLON .)
    LBRACE          reduce using rule 30 (decl_stmt -> type_specifier init_decl SEMICOLON .)
    ID              reduce using rule 30 (decl_stmt -> type_specifier init_decl SEMICOLON .)
    COUT            reduce using rule 30 (decl_stmt -> type_specifier init_decl SEMICOLON .)
    CIN             reduce using rule 30 (decl_stmt -> type_specifier init_decl SEMICOLON .)
    $end            reduce using rule 30 (decl_stmt -> type_specifier init_decl SEMICOLON .)
    SEMICOLON       reduce using rule 30 (decl_stmt -> type_specifier init_decl SEMICOLON .)
    RBRACE          reduce using rule 30 (decl_stmt -> type_specifier init_decl SEMICOLON .)
    ELSE            reduce using rule 30 (decl_stmt -> type_specifier init_decl SEMICOLON .)


state 78

    (36) assignment -> ID ASSIGN expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    SEMICOLON       reduce using rule 36 (assignment -> ID ASSIGN expression .)
    RPAREN          reduce using rule 36 (assignment -> ID ASSIGN expression .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 96
    MOD             shift and go to state 97
    EQ              shift and go to state 98
    NEQ             shift and go to state 99
    LT              shift and go to state 100
    GT              shift and go to state 101
    LE              shift and go to state 102
    GE              shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105


state 79

    (39) compound_assignment -> ID PLUS_ASSIGN expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    SEMICOLON       reduce using rule 39 (compound_assignment -> ID PLUS_ASSIGN expression .)
    RPAREN          reduce using rule 39 (compound_assignment -> ID PLUS_ASSIGN expression .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 96
    MOD             shift and go to state 97
    EQ              shift and go to state 98
    NEQ             shift and go to state 99
    LT              shift and go to state 100
    GT              shift and go to state 101
    LE              shift and go to state 102
    GE              shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105


state 80

    (40) compound_assignment -> ID MINUS_ASSIGN expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    SEMICOLON       reduce using rule 40 (compound_assignment -> ID MINUS_ASSIGN expression .)
    RPAREN          reduce using rule 40 (compound_assignment -> ID MINUS_ASSIGN expression .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 96
    MOD             shift and go to state 97
    EQ              shift and go to state 98
    NEQ             shift and go to state 99
    LT              shift and go to state 100
    GT              shift and go to state 101
    LE              shift and go to state 102
    GE              shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105


state 81

    (41) compound_assignment -> ID TIMES_ASSIGN expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    SEMICOLON       reduce using rule 41 (compound_assignment -> ID TIMES_ASSIGN expression .)
    RPAREN          reduce using rule 41 (compound_assignment -> ID TIMES_ASSIGN expression .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 96
    MOD             shift and go to state 97
    EQ              shift and go to state 98
    NEQ             shift and go to state 99
    LT              shift and go to state 100
    GT              shift and go to state 101
    LE              shift and go to state 102
    GE              shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105


state 82

    (42) compound_assignment -> ID DIVIDE_ASSIGN expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    SEMICOLON       reduce using rule 42 (compound_assignment -> ID DIVIDE_ASSIGN expression .)
    RPAREN          reduce using rule 42 (compound_assignment -> ID DIVIDE_ASSIGN expression .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 96
    MOD             shift and go to state 97
    EQ              shift and go to state 98
    NEQ             shift and go to state 99
    LT              shift and go to state 100
    GT              shift and go to state 101
    LE              shift and go to state 102
    GE              shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105


state 83

    (92) if_stmt -> IF LPAREN expression . RPAREN stmt ELSE stmt
    (93) if_stmt -> IF LPAREN expression . RPAREN stmt
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    RPAREN          shift and go to state 123
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 96
    MOD             shift and go to state 97
    EQ              shift and go to state 98
    NEQ             shift and go to state 99
    LT              shift and go to state 100
    GT              shift and go to state 101
    LE              shift and go to state 102
    GE              shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105


state 84

    (64) while_stmt -> WHILE LPAREN expression . RPAREN stmt
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    RPAREN          shift and go to state 124
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 96
    MOD             shift and go to state 97
    EQ              shift and go to state 98
    NEQ             shift and go to state 99
    LT              shift and go to state 100
    GT              shift and go to state 101
    LE              shift and go to state 102
    GE              shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105


state 85

    (65) for_stmt -> FOR LPAREN for_init . SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt

    SEMICOLON       shift and go to state 125


state 86

    (66) for_init -> decl_stmt .

    SEMICOLON       reduce using rule 66 (for_init -> decl_stmt .)


state 87

    (67) for_init -> assignment .

    SEMICOLON       reduce using rule 67 (for_init -> assignment .)


state 88

    (68) for_init -> unary_inc_dec .

    SEMICOLON       reduce using rule 68 (for_init -> unary_inc_dec .)


state 89

    (69) for_init -> compound_assignment .

    SEMICOLON       reduce using rule 69 (for_init -> compound_assignment .)


state 90

    (70) for_init -> empty .

    SEMICOLON       reduce using rule 70 (for_init -> empty .)


state 91

    (30) decl_stmt -> type_specifier . init_decl SEMICOLON
    (31) decl_stmt -> type_specifier . ID SEMICOLON
    (32) init_decl -> . ID ASSIGN expression

    ID              shift and go to state 126

    init_decl                      shift and go to state 40

state 92

    (94) return_stmt -> RETURN expression SEMICOLON .

    INT             reduce using rule 94 (return_stmt -> RETURN expression SEMICOLON .)
    FLOAT           reduce using rule 94 (return_stmt -> RETURN expression SEMICOLON .)
    DOUBLE          reduce using rule 94 (return_stmt -> RETURN expression SEMICOLON .)
    CHAR            reduce using rule 94 (return_stmt -> RETURN expression SEMICOLON .)
    BOOL            reduce using rule 94 (return_stmt -> RETURN expression SEMICOLON .)
    STRING          reduce using rule 94 (return_stmt -> RETURN expression SEMICOLON .)
    IF              reduce using rule 94 (return_stmt -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 94 (return_stmt -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 94 (return_stmt -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 94 (return_stmt -> RETURN expression SEMICOLON .)
    BREAK           reduce using rule 94 (return_stmt -> RETURN expression SEMICOLON .)
    CONTINUE        reduce using rule 94 (return_stmt -> RETURN expression SEMICOLON .)
    LBRACE          reduce using rule 94 (return_stmt -> RETURN expression SEMICOLON .)
    ID              reduce using rule 94 (return_stmt -> RETURN expression SEMICOLON .)
    COUT            reduce using rule 94 (return_stmt -> RETURN expression SEMICOLON .)
    CIN             reduce using rule 94 (return_stmt -> RETURN expression SEMICOLON .)
    $end            reduce using rule 94 (return_stmt -> RETURN expression SEMICOLON .)
    RBRACE          reduce using rule 94 (return_stmt -> RETURN expression SEMICOLON .)
    ELSE            reduce using rule 94 (return_stmt -> RETURN expression SEMICOLON .)


state 93

    (43) expression -> expression PLUS . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    expression                     shift and go to state 127

state 94

    (44) expression -> expression MINUS . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    expression                     shift and go to state 128

state 95

    (45) expression -> expression TIMES . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    expression                     shift and go to state 129

state 96

    (46) expression -> expression DIVIDE . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    expression                     shift and go to state 130

state 97

    (47) expression -> expression MOD . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    expression                     shift and go to state 131

state 98

    (48) expression -> expression EQ . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    expression                     shift and go to state 132

state 99

    (49) expression -> expression NEQ . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    expression                     shift and go to state 133

state 100

    (50) expression -> expression LT . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    expression                     shift and go to state 134

state 101

    (51) expression -> expression GT . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    expression                     shift and go to state 135

state 102

    (52) expression -> expression LE . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    expression                     shift and go to state 136

state 103

    (53) expression -> expression GE . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    expression                     shift and go to state 137

state 104

    (54) expression -> expression AND . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    expression                     shift and go to state 138

state 105

    (55) expression -> expression OR . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    expression                     shift and go to state 139

state 106

    (56) expression -> MINUS expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    SEMICOLON       reduce using rule 56 (expression -> MINUS expression .)
    PLUS            reduce using rule 56 (expression -> MINUS expression .)
    MINUS           reduce using rule 56 (expression -> MINUS expression .)
    TIMES           reduce using rule 56 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 56 (expression -> MINUS expression .)
    MOD             reduce using rule 56 (expression -> MINUS expression .)
    EQ              reduce using rule 56 (expression -> MINUS expression .)
    NEQ             reduce using rule 56 (expression -> MINUS expression .)
    LT              reduce using rule 56 (expression -> MINUS expression .)
    GT              reduce using rule 56 (expression -> MINUS expression .)
    LE              reduce using rule 56 (expression -> MINUS expression .)
    GE              reduce using rule 56 (expression -> MINUS expression .)
    AND             reduce using rule 56 (expression -> MINUS expression .)
    OR              reduce using rule 56 (expression -> MINUS expression .)
    RPAREN          reduce using rule 56 (expression -> MINUS expression .)
    LSHIFT          reduce using rule 56 (expression -> MINUS expression .)

  ! PLUS            [ shift and go to state 93 ]
  ! MINUS           [ shift and go to state 94 ]
  ! TIMES           [ shift and go to state 95 ]
  ! DIVIDE          [ shift and go to state 96 ]
  ! MOD             [ shift and go to state 97 ]
  ! EQ              [ shift and go to state 98 ]
  ! NEQ             [ shift and go to state 99 ]
  ! LT              [ shift and go to state 100 ]
  ! GT              [ shift and go to state 101 ]
  ! LE              [ shift and go to state 102 ]
  ! GE              [ shift and go to state 103 ]
  ! AND             [ shift and go to state 104 ]
  ! OR              [ shift and go to state 105 ]


state 107

    (57) expression -> NOT expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    SEMICOLON       reduce using rule 57 (expression -> NOT expression .)
    PLUS            reduce using rule 57 (expression -> NOT expression .)
    MINUS           reduce using rule 57 (expression -> NOT expression .)
    TIMES           reduce using rule 57 (expression -> NOT expression .)
    DIVIDE          reduce using rule 57 (expression -> NOT expression .)
    MOD             reduce using rule 57 (expression -> NOT expression .)
    EQ              reduce using rule 57 (expression -> NOT expression .)
    NEQ             reduce using rule 57 (expression -> NOT expression .)
    LT              reduce using rule 57 (expression -> NOT expression .)
    GT              reduce using rule 57 (expression -> NOT expression .)
    LE              reduce using rule 57 (expression -> NOT expression .)
    GE              reduce using rule 57 (expression -> NOT expression .)
    AND             reduce using rule 57 (expression -> NOT expression .)
    OR              reduce using rule 57 (expression -> NOT expression .)
    RPAREN          reduce using rule 57 (expression -> NOT expression .)
    LSHIFT          reduce using rule 57 (expression -> NOT expression .)

  ! PLUS            [ shift and go to state 93 ]
  ! MINUS           [ shift and go to state 94 ]
  ! TIMES           [ shift and go to state 95 ]
  ! DIVIDE          [ shift and go to state 96 ]
  ! MOD             [ shift and go to state 97 ]
  ! EQ              [ shift and go to state 98 ]
  ! NEQ             [ shift and go to state 99 ]
  ! LT              [ shift and go to state 100 ]
  ! GT              [ shift and go to state 101 ]
  ! LE              [ shift and go to state 102 ]
  ! GE              [ shift and go to state 103 ]
  ! AND             [ shift and go to state 104 ]
  ! OR              [ shift and go to state 105 ]


state 108

    (58) expression -> LPAREN expression . RPAREN
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    RPAREN          shift and go to state 140
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 96
    MOD             shift and go to state 97
    EQ              shift and go to state 98
    NEQ             shift and go to state 99
    LT              shift and go to state 100
    GT              shift and go to state 101
    LE              shift and go to state 102
    GE              shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105


state 109

    (17) block -> LBRACE stmt_list RBRACE .

    INT             reduce using rule 17 (block -> LBRACE stmt_list RBRACE .)
    FLOAT           reduce using rule 17 (block -> LBRACE stmt_list RBRACE .)
    DOUBLE          reduce using rule 17 (block -> LBRACE stmt_list RBRACE .)
    CHAR            reduce using rule 17 (block -> LBRACE stmt_list RBRACE .)
    BOOL            reduce using rule 17 (block -> LBRACE stmt_list RBRACE .)
    STRING          reduce using rule 17 (block -> LBRACE stmt_list RBRACE .)
    IF              reduce using rule 17 (block -> LBRACE stmt_list RBRACE .)
    WHILE           reduce using rule 17 (block -> LBRACE stmt_list RBRACE .)
    FOR             reduce using rule 17 (block -> LBRACE stmt_list RBRACE .)
    RETURN          reduce using rule 17 (block -> LBRACE stmt_list RBRACE .)
    BREAK           reduce using rule 17 (block -> LBRACE stmt_list RBRACE .)
    CONTINUE        reduce using rule 17 (block -> LBRACE stmt_list RBRACE .)
    LBRACE          reduce using rule 17 (block -> LBRACE stmt_list RBRACE .)
    ID              reduce using rule 17 (block -> LBRACE stmt_list RBRACE .)
    COUT            reduce using rule 17 (block -> LBRACE stmt_list RBRACE .)
    CIN             reduce using rule 17 (block -> LBRACE stmt_list RBRACE .)
    $end            reduce using rule 17 (block -> LBRACE stmt_list RBRACE .)
    RBRACE          reduce using rule 17 (block -> LBRACE stmt_list RBRACE .)
    ELSE            reduce using rule 17 (block -> LBRACE stmt_list RBRACE .)


state 110

    (18) stmt_list -> stmt_list stmt .

    RBRACE          reduce using rule 18 (stmt_list -> stmt_list stmt .)
    IF              reduce using rule 18 (stmt_list -> stmt_list stmt .)
    WHILE           reduce using rule 18 (stmt_list -> stmt_list stmt .)
    FOR             reduce using rule 18 (stmt_list -> stmt_list stmt .)
    RETURN          reduce using rule 18 (stmt_list -> stmt_list stmt .)
    BREAK           reduce using rule 18 (stmt_list -> stmt_list stmt .)
    CONTINUE        reduce using rule 18 (stmt_list -> stmt_list stmt .)
    LBRACE          reduce using rule 18 (stmt_list -> stmt_list stmt .)
    INT             reduce using rule 18 (stmt_list -> stmt_list stmt .)
    FLOAT           reduce using rule 18 (stmt_list -> stmt_list stmt .)
    DOUBLE          reduce using rule 18 (stmt_list -> stmt_list stmt .)
    CHAR            reduce using rule 18 (stmt_list -> stmt_list stmt .)
    BOOL            reduce using rule 18 (stmt_list -> stmt_list stmt .)
    STRING          reduce using rule 18 (stmt_list -> stmt_list stmt .)
    ID              reduce using rule 18 (stmt_list -> stmt_list stmt .)
    COUT            reduce using rule 18 (stmt_list -> stmt_list stmt .)
    CIN             reduce using rule 18 (stmt_list -> stmt_list stmt .)


state 111

    (82) insertion_list -> LSHIFT insertion_items .
    (83) insertion_items -> insertion_items . LSHIFT insertion_item

    SEMICOLON       reduce using rule 82 (insertion_list -> LSHIFT insertion_items .)
    LSHIFT          shift and go to state 141


state 112

    (84) insertion_items -> insertion_item .

    LSHIFT          reduce using rule 84 (insertion_items -> insertion_item .)
    SEMICOLON       reduce using rule 84 (insertion_items -> insertion_item .)


state 113

    (85) insertion_item -> expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    LSHIFT          reduce using rule 85 (insertion_item -> expression .)
    SEMICOLON       reduce using rule 85 (insertion_item -> expression .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 96
    MOD             shift and go to state 97
    EQ              shift and go to state 98
    NEQ             shift and go to state 99
    LT              shift and go to state 100
    GT              shift and go to state 101
    LE              shift and go to state 102
    GE              shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105


state 114

    (86) insertion_item -> ENDL .

    LSHIFT          reduce using rule 86 (insertion_item -> ENDL .)
    SEMICOLON       reduce using rule 86 (insertion_item -> ENDL .)


state 115

    (88) extraction_list -> RSHIFT extraction_items .
    (89) extraction_items -> extraction_items . RSHIFT extraction_target

    SEMICOLON       reduce using rule 88 (extraction_list -> RSHIFT extraction_items .)
    RSHIFT          shift and go to state 142


state 116

    (90) extraction_items -> extraction_target .

    RSHIFT          reduce using rule 90 (extraction_items -> extraction_target .)
    SEMICOLON       reduce using rule 90 (extraction_items -> extraction_target .)


state 117

    (91) extraction_target -> ID .

    RSHIFT          reduce using rule 91 (extraction_target -> ID .)
    SEMICOLON       reduce using rule 91 (extraction_target -> ID .)


state 118

    (10) param -> type_specifier . ID

    ID              shift and go to state 143


state 119

    (6) function_def -> type_specifier ID LPAREN param_list . RPAREN block
    (7) param_list -> param_list . COMMA param

    RPAREN          shift and go to state 144
    COMMA           shift and go to state 145


state 120

    (8) param_list -> param .

    RPAREN          reduce using rule 8 (param_list -> param .)
    COMMA           reduce using rule 8 (param_list -> param .)


state 121

    (9) param_list -> empty .

    RPAREN          reduce using rule 9 (param_list -> empty .)
    COMMA           reduce using rule 9 (param_list -> empty .)


state 122

    (32) init_decl -> ID ASSIGN expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    SEMICOLON       reduce using rule 32 (init_decl -> ID ASSIGN expression .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 96
    MOD             shift and go to state 97
    EQ              shift and go to state 98
    NEQ             shift and go to state 99
    LT              shift and go to state 100
    GT              shift and go to state 101
    LE              shift and go to state 102
    GE              shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105


state 123

    (92) if_stmt -> IF LPAREN expression RPAREN . stmt ELSE stmt
    (93) if_stmt -> IF LPAREN expression RPAREN . stmt
    (20) stmt -> . decl_stmt
    (21) stmt -> . expr_stmt
    (22) stmt -> . if_stmt
    (23) stmt -> . while_stmt
    (24) stmt -> . for_stmt
    (25) stmt -> . io_stmt
    (26) stmt -> . return_stmt
    (27) stmt -> . break_stmt
    (28) stmt -> . continue_stmt
    (29) stmt -> . block
    (30) decl_stmt -> . type_specifier init_decl SEMICOLON
    (31) decl_stmt -> . type_specifier ID SEMICOLON
    (33) expr_stmt -> . assignment SEMICOLON
    (34) expr_stmt -> . unary_inc_dec SEMICOLON
    (35) expr_stmt -> . compound_assignment SEMICOLON
    (92) if_stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (93) if_stmt -> . IF LPAREN expression RPAREN stmt
    (64) while_stmt -> . WHILE LPAREN expression RPAREN stmt
    (65) for_stmt -> . FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt
    (79) io_stmt -> . cout_stmt SEMICOLON
    (80) io_stmt -> . cin_stmt SEMICOLON
    (94) return_stmt -> . RETURN expression SEMICOLON
    (95) return_stmt -> . RETURN SEMICOLON
    (96) break_stmt -> . BREAK SEMICOLON
    (97) continue_stmt -> . CONTINUE SEMICOLON
    (17) block -> . LBRACE stmt_list RBRACE
    (11) type_specifier -> . INT
    (12) type_specifier -> . FLOAT
    (13) type_specifier -> . DOUBLE
    (14) type_specifier -> . CHAR
    (15) type_specifier -> . BOOL
    (16) type_specifier -> . STRING
    (36) assignment -> . ID ASSIGN expression
    (37) unary_inc_dec -> . ID INC
    (38) unary_inc_dec -> . ID DEC
    (39) compound_assignment -> . ID PLUS_ASSIGN expression
    (40) compound_assignment -> . ID MINUS_ASSIGN expression
    (41) compound_assignment -> . ID TIMES_ASSIGN expression
    (42) compound_assignment -> . ID DIVIDE_ASSIGN expression
    (81) cout_stmt -> . COUT insertion_list
    (87) cin_stmt -> . CIN extraction_list

    IF              shift and go to state 27
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    LBRACE          shift and go to state 35
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    DOUBLE          shift and go to state 20
    CHAR            shift and go to state 21
    BOOL            shift and go to state 22
    STRING          shift and go to state 23
    ID              shift and go to state 7
    COUT            shift and go to state 36
    CIN             shift and go to state 37

    stmt                           shift and go to state 146
    decl_stmt                      shift and go to state 9
    expr_stmt                      shift and go to state 10
    if_stmt                        shift and go to state 11
    while_stmt                     shift and go to state 12
    for_stmt                       shift and go to state 13
    io_stmt                        shift and go to state 14
    return_stmt                    shift and go to state 15
    break_stmt                     shift and go to state 16
    continue_stmt                  shift and go to state 17
    block                          shift and go to state 8
    type_specifier                 shift and go to state 91
    assignment                     shift and go to state 24
    unary_inc_dec                  shift and go to state 25
    compound_assignment            shift and go to state 26
    cout_stmt                      shift and go to state 30
    cin_stmt                       shift and go to state 31

state 124

    (64) while_stmt -> WHILE LPAREN expression RPAREN . stmt
    (20) stmt -> . decl_stmt
    (21) stmt -> . expr_stmt
    (22) stmt -> . if_stmt
    (23) stmt -> . while_stmt
    (24) stmt -> . for_stmt
    (25) stmt -> . io_stmt
    (26) stmt -> . return_stmt
    (27) stmt -> . break_stmt
    (28) stmt -> . continue_stmt
    (29) stmt -> . block
    (30) decl_stmt -> . type_specifier init_decl SEMICOLON
    (31) decl_stmt -> . type_specifier ID SEMICOLON
    (33) expr_stmt -> . assignment SEMICOLON
    (34) expr_stmt -> . unary_inc_dec SEMICOLON
    (35) expr_stmt -> . compound_assignment SEMICOLON
    (92) if_stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (93) if_stmt -> . IF LPAREN expression RPAREN stmt
    (64) while_stmt -> . WHILE LPAREN expression RPAREN stmt
    (65) for_stmt -> . FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt
    (79) io_stmt -> . cout_stmt SEMICOLON
    (80) io_stmt -> . cin_stmt SEMICOLON
    (94) return_stmt -> . RETURN expression SEMICOLON
    (95) return_stmt -> . RETURN SEMICOLON
    (96) break_stmt -> . BREAK SEMICOLON
    (97) continue_stmt -> . CONTINUE SEMICOLON
    (17) block -> . LBRACE stmt_list RBRACE
    (11) type_specifier -> . INT
    (12) type_specifier -> . FLOAT
    (13) type_specifier -> . DOUBLE
    (14) type_specifier -> . CHAR
    (15) type_specifier -> . BOOL
    (16) type_specifier -> . STRING
    (36) assignment -> . ID ASSIGN expression
    (37) unary_inc_dec -> . ID INC
    (38) unary_inc_dec -> . ID DEC
    (39) compound_assignment -> . ID PLUS_ASSIGN expression
    (40) compound_assignment -> . ID MINUS_ASSIGN expression
    (41) compound_assignment -> . ID TIMES_ASSIGN expression
    (42) compound_assignment -> . ID DIVIDE_ASSIGN expression
    (81) cout_stmt -> . COUT insertion_list
    (87) cin_stmt -> . CIN extraction_list

    IF              shift and go to state 27
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    LBRACE          shift and go to state 35
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    DOUBLE          shift and go to state 20
    CHAR            shift and go to state 21
    BOOL            shift and go to state 22
    STRING          shift and go to state 23
    ID              shift and go to state 7
    COUT            shift and go to state 36
    CIN             shift and go to state 37

    stmt                           shift and go to state 147
    decl_stmt                      shift and go to state 9
    expr_stmt                      shift and go to state 10
    if_stmt                        shift and go to state 11
    while_stmt                     shift and go to state 12
    for_stmt                       shift and go to state 13
    io_stmt                        shift and go to state 14
    return_stmt                    shift and go to state 15
    break_stmt                     shift and go to state 16
    continue_stmt                  shift and go to state 17
    block                          shift and go to state 8
    type_specifier                 shift and go to state 91
    assignment                     shift and go to state 24
    unary_inc_dec                  shift and go to state 25
    compound_assignment            shift and go to state 26
    cout_stmt                      shift and go to state 30
    cin_stmt                       shift and go to state 31

state 125

    (65) for_stmt -> FOR LPAREN for_init SEMICOLON . for_cond SEMICOLON for_iter RPAREN stmt
    (71) for_cond -> . expression
    (72) for_cond -> . empty
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID
    (98) empty -> .

    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65
    SEMICOLON       reduce using rule 98 (empty -> .)

    for_cond                       shift and go to state 148
    expression                     shift and go to state 149
    empty                          shift and go to state 150

state 126

    (31) decl_stmt -> type_specifier ID . SEMICOLON
    (32) init_decl -> ID . ASSIGN expression

    SEMICOLON       shift and go to state 75
    ASSIGN          shift and go to state 76


state 127

    (43) expression -> expression PLUS expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    SEMICOLON       reduce using rule 43 (expression -> expression PLUS expression .)
    PLUS            reduce using rule 43 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 43 (expression -> expression PLUS expression .)
    EQ              reduce using rule 43 (expression -> expression PLUS expression .)
    NEQ             reduce using rule 43 (expression -> expression PLUS expression .)
    LT              reduce using rule 43 (expression -> expression PLUS expression .)
    GT              reduce using rule 43 (expression -> expression PLUS expression .)
    LE              reduce using rule 43 (expression -> expression PLUS expression .)
    GE              reduce using rule 43 (expression -> expression PLUS expression .)
    AND             reduce using rule 43 (expression -> expression PLUS expression .)
    OR              reduce using rule 43 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 43 (expression -> expression PLUS expression .)
    LSHIFT          reduce using rule 43 (expression -> expression PLUS expression .)
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 96
    MOD             shift and go to state 97

  ! TIMES           [ reduce using rule 43 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 43 (expression -> expression PLUS expression .) ]
  ! MOD             [ reduce using rule 43 (expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 93 ]
  ! MINUS           [ shift and go to state 94 ]
  ! EQ              [ shift and go to state 98 ]
  ! NEQ             [ shift and go to state 99 ]
  ! LT              [ shift and go to state 100 ]
  ! GT              [ shift and go to state 101 ]
  ! LE              [ shift and go to state 102 ]
  ! GE              [ shift and go to state 103 ]
  ! AND             [ shift and go to state 104 ]
  ! OR              [ shift and go to state 105 ]


state 128

    (44) expression -> expression MINUS expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    SEMICOLON       reduce using rule 44 (expression -> expression MINUS expression .)
    PLUS            reduce using rule 44 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 44 (expression -> expression MINUS expression .)
    EQ              reduce using rule 44 (expression -> expression MINUS expression .)
    NEQ             reduce using rule 44 (expression -> expression MINUS expression .)
    LT              reduce using rule 44 (expression -> expression MINUS expression .)
    GT              reduce using rule 44 (expression -> expression MINUS expression .)
    LE              reduce using rule 44 (expression -> expression MINUS expression .)
    GE              reduce using rule 44 (expression -> expression MINUS expression .)
    AND             reduce using rule 44 (expression -> expression MINUS expression .)
    OR              reduce using rule 44 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 44 (expression -> expression MINUS expression .)
    LSHIFT          reduce using rule 44 (expression -> expression MINUS expression .)
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 96
    MOD             shift and go to state 97

  ! TIMES           [ reduce using rule 44 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 44 (expression -> expression MINUS expression .) ]
  ! MOD             [ reduce using rule 44 (expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 93 ]
  ! MINUS           [ shift and go to state 94 ]
  ! EQ              [ shift and go to state 98 ]
  ! NEQ             [ shift and go to state 99 ]
  ! LT              [ shift and go to state 100 ]
  ! GT              [ shift and go to state 101 ]
  ! LE              [ shift and go to state 102 ]
  ! GE              [ shift and go to state 103 ]
  ! AND             [ shift and go to state 104 ]
  ! OR              [ shift and go to state 105 ]


state 129

    (45) expression -> expression TIMES expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    SEMICOLON       reduce using rule 45 (expression -> expression TIMES expression .)
    PLUS            reduce using rule 45 (expression -> expression TIMES expression .)
    MINUS           reduce using rule 45 (expression -> expression TIMES expression .)
    TIMES           reduce using rule 45 (expression -> expression TIMES expression .)
    DIVIDE          reduce using rule 45 (expression -> expression TIMES expression .)
    MOD             reduce using rule 45 (expression -> expression TIMES expression .)
    EQ              reduce using rule 45 (expression -> expression TIMES expression .)
    NEQ             reduce using rule 45 (expression -> expression TIMES expression .)
    LT              reduce using rule 45 (expression -> expression TIMES expression .)
    GT              reduce using rule 45 (expression -> expression TIMES expression .)
    LE              reduce using rule 45 (expression -> expression TIMES expression .)
    GE              reduce using rule 45 (expression -> expression TIMES expression .)
    AND             reduce using rule 45 (expression -> expression TIMES expression .)
    OR              reduce using rule 45 (expression -> expression TIMES expression .)
    RPAREN          reduce using rule 45 (expression -> expression TIMES expression .)
    LSHIFT          reduce using rule 45 (expression -> expression TIMES expression .)

  ! PLUS            [ shift and go to state 93 ]
  ! MINUS           [ shift and go to state 94 ]
  ! TIMES           [ shift and go to state 95 ]
  ! DIVIDE          [ shift and go to state 96 ]
  ! MOD             [ shift and go to state 97 ]
  ! EQ              [ shift and go to state 98 ]
  ! NEQ             [ shift and go to state 99 ]
  ! LT              [ shift and go to state 100 ]
  ! GT              [ shift and go to state 101 ]
  ! LE              [ shift and go to state 102 ]
  ! GE              [ shift and go to state 103 ]
  ! AND             [ shift and go to state 104 ]
  ! OR              [ shift and go to state 105 ]


state 130

    (46) expression -> expression DIVIDE expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    SEMICOLON       reduce using rule 46 (expression -> expression DIVIDE expression .)
    PLUS            reduce using rule 46 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 46 (expression -> expression DIVIDE expression .)
    TIMES           reduce using rule 46 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 46 (expression -> expression DIVIDE expression .)
    MOD             reduce using rule 46 (expression -> expression DIVIDE expression .)
    EQ              reduce using rule 46 (expression -> expression DIVIDE expression .)
    NEQ             reduce using rule 46 (expression -> expression DIVIDE expression .)
    LT              reduce using rule 46 (expression -> expression DIVIDE expression .)
    GT              reduce using rule 46 (expression -> expression DIVIDE expression .)
    LE              reduce using rule 46 (expression -> expression DIVIDE expression .)
    GE              reduce using rule 46 (expression -> expression DIVIDE expression .)
    AND             reduce using rule 46 (expression -> expression DIVIDE expression .)
    OR              reduce using rule 46 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 46 (expression -> expression DIVIDE expression .)
    LSHIFT          reduce using rule 46 (expression -> expression DIVIDE expression .)

  ! PLUS            [ shift and go to state 93 ]
  ! MINUS           [ shift and go to state 94 ]
  ! TIMES           [ shift and go to state 95 ]
  ! DIVIDE          [ shift and go to state 96 ]
  ! MOD             [ shift and go to state 97 ]
  ! EQ              [ shift and go to state 98 ]
  ! NEQ             [ shift and go to state 99 ]
  ! LT              [ shift and go to state 100 ]
  ! GT              [ shift and go to state 101 ]
  ! LE              [ shift and go to state 102 ]
  ! GE              [ shift and go to state 103 ]
  ! AND             [ shift and go to state 104 ]
  ! OR              [ shift and go to state 105 ]


state 131

    (47) expression -> expression MOD expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    SEMICOLON       reduce using rule 47 (expression -> expression MOD expression .)
    PLUS            reduce using rule 47 (expression -> expression MOD expression .)
    MINUS           reduce using rule 47 (expression -> expression MOD expression .)
    TIMES           reduce using rule 47 (expression -> expression MOD expression .)
    DIVIDE          reduce using rule 47 (expression -> expression MOD expression .)
    MOD             reduce using rule 47 (expression -> expression MOD expression .)
    EQ              reduce using rule 47 (expression -> expression MOD expression .)
    NEQ             reduce using rule 47 (expression -> expression MOD expression .)
    LT              reduce using rule 47 (expression -> expression MOD expression .)
    GT              reduce using rule 47 (expression -> expression MOD expression .)
    LE              reduce using rule 47 (expression -> expression MOD expression .)
    GE              reduce using rule 47 (expression -> expression MOD expression .)
    AND             reduce using rule 47 (expression -> expression MOD expression .)
    OR              reduce using rule 47 (expression -> expression MOD expression .)
    RPAREN          reduce using rule 47 (expression -> expression MOD expression .)
    LSHIFT          reduce using rule 47 (expression -> expression MOD expression .)

  ! PLUS            [ shift and go to state 93 ]
  ! MINUS           [ shift and go to state 94 ]
  ! TIMES           [ shift and go to state 95 ]
  ! DIVIDE          [ shift and go to state 96 ]
  ! MOD             [ shift and go to state 97 ]
  ! EQ              [ shift and go to state 98 ]
  ! NEQ             [ shift and go to state 99 ]
  ! LT              [ shift and go to state 100 ]
  ! GT              [ shift and go to state 101 ]
  ! LE              [ shift and go to state 102 ]
  ! GE              [ shift and go to state 103 ]
  ! AND             [ shift and go to state 104 ]
  ! OR              [ shift and go to state 105 ]


state 132

    (48) expression -> expression EQ expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    SEMICOLON       reduce using rule 48 (expression -> expression EQ expression .)
    EQ              reduce using rule 48 (expression -> expression EQ expression .)
    NEQ             reduce using rule 48 (expression -> expression EQ expression .)
    AND             reduce using rule 48 (expression -> expression EQ expression .)
    OR              reduce using rule 48 (expression -> expression EQ expression .)
    RPAREN          reduce using rule 48 (expression -> expression EQ expression .)
    LSHIFT          reduce using rule 48 (expression -> expression EQ expression .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 96
    MOD             shift and go to state 97
    LT              shift and go to state 100
    GT              shift and go to state 101
    LE              shift and go to state 102
    GE              shift and go to state 103

  ! PLUS            [ reduce using rule 48 (expression -> expression EQ expression .) ]
  ! MINUS           [ reduce using rule 48 (expression -> expression EQ expression .) ]
  ! TIMES           [ reduce using rule 48 (expression -> expression EQ expression .) ]
  ! DIVIDE          [ reduce using rule 48 (expression -> expression EQ expression .) ]
  ! MOD             [ reduce using rule 48 (expression -> expression EQ expression .) ]
  ! LT              [ reduce using rule 48 (expression -> expression EQ expression .) ]
  ! GT              [ reduce using rule 48 (expression -> expression EQ expression .) ]
  ! LE              [ reduce using rule 48 (expression -> expression EQ expression .) ]
  ! GE              [ reduce using rule 48 (expression -> expression EQ expression .) ]
  ! EQ              [ shift and go to state 98 ]
  ! NEQ             [ shift and go to state 99 ]
  ! AND             [ shift and go to state 104 ]
  ! OR              [ shift and go to state 105 ]


state 133

    (49) expression -> expression NEQ expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    SEMICOLON       reduce using rule 49 (expression -> expression NEQ expression .)
    EQ              reduce using rule 49 (expression -> expression NEQ expression .)
    NEQ             reduce using rule 49 (expression -> expression NEQ expression .)
    AND             reduce using rule 49 (expression -> expression NEQ expression .)
    OR              reduce using rule 49 (expression -> expression NEQ expression .)
    RPAREN          reduce using rule 49 (expression -> expression NEQ expression .)
    LSHIFT          reduce using rule 49 (expression -> expression NEQ expression .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 96
    MOD             shift and go to state 97
    LT              shift and go to state 100
    GT              shift and go to state 101
    LE              shift and go to state 102
    GE              shift and go to state 103

  ! PLUS            [ reduce using rule 49 (expression -> expression NEQ expression .) ]
  ! MINUS           [ reduce using rule 49 (expression -> expression NEQ expression .) ]
  ! TIMES           [ reduce using rule 49 (expression -> expression NEQ expression .) ]
  ! DIVIDE          [ reduce using rule 49 (expression -> expression NEQ expression .) ]
  ! MOD             [ reduce using rule 49 (expression -> expression NEQ expression .) ]
  ! LT              [ reduce using rule 49 (expression -> expression NEQ expression .) ]
  ! GT              [ reduce using rule 49 (expression -> expression NEQ expression .) ]
  ! LE              [ reduce using rule 49 (expression -> expression NEQ expression .) ]
  ! GE              [ reduce using rule 49 (expression -> expression NEQ expression .) ]
  ! EQ              [ shift and go to state 98 ]
  ! NEQ             [ shift and go to state 99 ]
  ! AND             [ shift and go to state 104 ]
  ! OR              [ shift and go to state 105 ]


state 134

    (50) expression -> expression LT expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    SEMICOLON       reduce using rule 50 (expression -> expression LT expression .)
    EQ              reduce using rule 50 (expression -> expression LT expression .)
    NEQ             reduce using rule 50 (expression -> expression LT expression .)
    LT              reduce using rule 50 (expression -> expression LT expression .)
    GT              reduce using rule 50 (expression -> expression LT expression .)
    LE              reduce using rule 50 (expression -> expression LT expression .)
    GE              reduce using rule 50 (expression -> expression LT expression .)
    AND             reduce using rule 50 (expression -> expression LT expression .)
    OR              reduce using rule 50 (expression -> expression LT expression .)
    RPAREN          reduce using rule 50 (expression -> expression LT expression .)
    LSHIFT          reduce using rule 50 (expression -> expression LT expression .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 96
    MOD             shift and go to state 97

  ! PLUS            [ reduce using rule 50 (expression -> expression LT expression .) ]
  ! MINUS           [ reduce using rule 50 (expression -> expression LT expression .) ]
  ! TIMES           [ reduce using rule 50 (expression -> expression LT expression .) ]
  ! DIVIDE          [ reduce using rule 50 (expression -> expression LT expression .) ]
  ! MOD             [ reduce using rule 50 (expression -> expression LT expression .) ]
  ! EQ              [ shift and go to state 98 ]
  ! NEQ             [ shift and go to state 99 ]
  ! LT              [ shift and go to state 100 ]
  ! GT              [ shift and go to state 101 ]
  ! LE              [ shift and go to state 102 ]
  ! GE              [ shift and go to state 103 ]
  ! AND             [ shift and go to state 104 ]
  ! OR              [ shift and go to state 105 ]


state 135

    (51) expression -> expression GT expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    SEMICOLON       reduce using rule 51 (expression -> expression GT expression .)
    EQ              reduce using rule 51 (expression -> expression GT expression .)
    NEQ             reduce using rule 51 (expression -> expression GT expression .)
    LT              reduce using rule 51 (expression -> expression GT expression .)
    GT              reduce using rule 51 (expression -> expression GT expression .)
    LE              reduce using rule 51 (expression -> expression GT expression .)
    GE              reduce using rule 51 (expression -> expression GT expression .)
    AND             reduce using rule 51 (expression -> expression GT expression .)
    OR              reduce using rule 51 (expression -> expression GT expression .)
    RPAREN          reduce using rule 51 (expression -> expression GT expression .)
    LSHIFT          reduce using rule 51 (expression -> expression GT expression .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 96
    MOD             shift and go to state 97

  ! PLUS            [ reduce using rule 51 (expression -> expression GT expression .) ]
  ! MINUS           [ reduce using rule 51 (expression -> expression GT expression .) ]
  ! TIMES           [ reduce using rule 51 (expression -> expression GT expression .) ]
  ! DIVIDE          [ reduce using rule 51 (expression -> expression GT expression .) ]
  ! MOD             [ reduce using rule 51 (expression -> expression GT expression .) ]
  ! EQ              [ shift and go to state 98 ]
  ! NEQ             [ shift and go to state 99 ]
  ! LT              [ shift and go to state 100 ]
  ! GT              [ shift and go to state 101 ]
  ! LE              [ shift and go to state 102 ]
  ! GE              [ shift and go to state 103 ]
  ! AND             [ shift and go to state 104 ]
  ! OR              [ shift and go to state 105 ]


state 136

    (52) expression -> expression LE expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    SEMICOLON       reduce using rule 52 (expression -> expression LE expression .)
    EQ              reduce using rule 52 (expression -> expression LE expression .)
    NEQ             reduce using rule 52 (expression -> expression LE expression .)
    LT              reduce using rule 52 (expression -> expression LE expression .)
    GT              reduce using rule 52 (expression -> expression LE expression .)
    LE              reduce using rule 52 (expression -> expression LE expression .)
    GE              reduce using rule 52 (expression -> expression LE expression .)
    AND             reduce using rule 52 (expression -> expression LE expression .)
    OR              reduce using rule 52 (expression -> expression LE expression .)
    RPAREN          reduce using rule 52 (expression -> expression LE expression .)
    LSHIFT          reduce using rule 52 (expression -> expression LE expression .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 96
    MOD             shift and go to state 97

  ! PLUS            [ reduce using rule 52 (expression -> expression LE expression .) ]
  ! MINUS           [ reduce using rule 52 (expression -> expression LE expression .) ]
  ! TIMES           [ reduce using rule 52 (expression -> expression LE expression .) ]
  ! DIVIDE          [ reduce using rule 52 (expression -> expression LE expression .) ]
  ! MOD             [ reduce using rule 52 (expression -> expression LE expression .) ]
  ! EQ              [ shift and go to state 98 ]
  ! NEQ             [ shift and go to state 99 ]
  ! LT              [ shift and go to state 100 ]
  ! GT              [ shift and go to state 101 ]
  ! LE              [ shift and go to state 102 ]
  ! GE              [ shift and go to state 103 ]
  ! AND             [ shift and go to state 104 ]
  ! OR              [ shift and go to state 105 ]


state 137

    (53) expression -> expression GE expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    SEMICOLON       reduce using rule 53 (expression -> expression GE expression .)
    EQ              reduce using rule 53 (expression -> expression GE expression .)
    NEQ             reduce using rule 53 (expression -> expression GE expression .)
    LT              reduce using rule 53 (expression -> expression GE expression .)
    GT              reduce using rule 53 (expression -> expression GE expression .)
    LE              reduce using rule 53 (expression -> expression GE expression .)
    GE              reduce using rule 53 (expression -> expression GE expression .)
    AND             reduce using rule 53 (expression -> expression GE expression .)
    OR              reduce using rule 53 (expression -> expression GE expression .)
    RPAREN          reduce using rule 53 (expression -> expression GE expression .)
    LSHIFT          reduce using rule 53 (expression -> expression GE expression .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 96
    MOD             shift and go to state 97

  ! PLUS            [ reduce using rule 53 (expression -> expression GE expression .) ]
  ! MINUS           [ reduce using rule 53 (expression -> expression GE expression .) ]
  ! TIMES           [ reduce using rule 53 (expression -> expression GE expression .) ]
  ! DIVIDE          [ reduce using rule 53 (expression -> expression GE expression .) ]
  ! MOD             [ reduce using rule 53 (expression -> expression GE expression .) ]
  ! EQ              [ shift and go to state 98 ]
  ! NEQ             [ shift and go to state 99 ]
  ! LT              [ shift and go to state 100 ]
  ! GT              [ shift and go to state 101 ]
  ! LE              [ shift and go to state 102 ]
  ! GE              [ shift and go to state 103 ]
  ! AND             [ shift and go to state 104 ]
  ! OR              [ shift and go to state 105 ]


state 138

    (54) expression -> expression AND expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    SEMICOLON       reduce using rule 54 (expression -> expression AND expression .)
    AND             reduce using rule 54 (expression -> expression AND expression .)
    OR              reduce using rule 54 (expression -> expression AND expression .)
    RPAREN          reduce using rule 54 (expression -> expression AND expression .)
    LSHIFT          reduce using rule 54 (expression -> expression AND expression .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 96
    MOD             shift and go to state 97
    EQ              shift and go to state 98
    NEQ             shift and go to state 99
    LT              shift and go to state 100
    GT              shift and go to state 101
    LE              shift and go to state 102
    GE              shift and go to state 103

  ! PLUS            [ reduce using rule 54 (expression -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 54 (expression -> expression AND expression .) ]
  ! TIMES           [ reduce using rule 54 (expression -> expression AND expression .) ]
  ! DIVIDE          [ reduce using rule 54 (expression -> expression AND expression .) ]
  ! MOD             [ reduce using rule 54 (expression -> expression AND expression .) ]
  ! EQ              [ reduce using rule 54 (expression -> expression AND expression .) ]
  ! NEQ             [ reduce using rule 54 (expression -> expression AND expression .) ]
  ! LT              [ reduce using rule 54 (expression -> expression AND expression .) ]
  ! GT              [ reduce using rule 54 (expression -> expression AND expression .) ]
  ! LE              [ reduce using rule 54 (expression -> expression AND expression .) ]
  ! GE              [ reduce using rule 54 (expression -> expression AND expression .) ]
  ! AND             [ shift and go to state 104 ]
  ! OR              [ shift and go to state 105 ]


state 139

    (55) expression -> expression OR expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    SEMICOLON       reduce using rule 55 (expression -> expression OR expression .)
    OR              reduce using rule 55 (expression -> expression OR expression .)
    RPAREN          reduce using rule 55 (expression -> expression OR expression .)
    LSHIFT          reduce using rule 55 (expression -> expression OR expression .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 96
    MOD             shift and go to state 97
    EQ              shift and go to state 98
    NEQ             shift and go to state 99
    LT              shift and go to state 100
    GT              shift and go to state 101
    LE              shift and go to state 102
    GE              shift and go to state 103
    AND             shift and go to state 104

  ! PLUS            [ reduce using rule 55 (expression -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 55 (expression -> expression OR expression .) ]
  ! TIMES           [ reduce using rule 55 (expression -> expression OR expression .) ]
  ! DIVIDE          [ reduce using rule 55 (expression -> expression OR expression .) ]
  ! MOD             [ reduce using rule 55 (expression -> expression OR expression .) ]
  ! EQ              [ reduce using rule 55 (expression -> expression OR expression .) ]
  ! NEQ             [ reduce using rule 55 (expression -> expression OR expression .) ]
  ! LT              [ reduce using rule 55 (expression -> expression OR expression .) ]
  ! GT              [ reduce using rule 55 (expression -> expression OR expression .) ]
  ! LE              [ reduce using rule 55 (expression -> expression OR expression .) ]
  ! GE              [ reduce using rule 55 (expression -> expression OR expression .) ]
  ! AND             [ reduce using rule 55 (expression -> expression OR expression .) ]
  ! OR              [ shift and go to state 105 ]


state 140

    (58) expression -> LPAREN expression RPAREN .

    SEMICOLON       reduce using rule 58 (expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 58 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 58 (expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 58 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 58 (expression -> LPAREN expression RPAREN .)
    MOD             reduce using rule 58 (expression -> LPAREN expression RPAREN .)
    EQ              reduce using rule 58 (expression -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 58 (expression -> LPAREN expression RPAREN .)
    LT              reduce using rule 58 (expression -> LPAREN expression RPAREN .)
    GT              reduce using rule 58 (expression -> LPAREN expression RPAREN .)
    LE              reduce using rule 58 (expression -> LPAREN expression RPAREN .)
    GE              reduce using rule 58 (expression -> LPAREN expression RPAREN .)
    AND             reduce using rule 58 (expression -> LPAREN expression RPAREN .)
    OR              reduce using rule 58 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 58 (expression -> LPAREN expression RPAREN .)
    LSHIFT          reduce using rule 58 (expression -> LPAREN expression RPAREN .)


state 141

    (83) insertion_items -> insertion_items LSHIFT . insertion_item
    (85) insertion_item -> . expression
    (86) insertion_item -> . ENDL
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression TIMES expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression MOD expression
    (48) expression -> . expression EQ expression
    (49) expression -> . expression NEQ expression
    (50) expression -> . expression LT expression
    (51) expression -> . expression GT expression
    (52) expression -> . expression LE expression
    (53) expression -> . expression GE expression
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . MINUS expression
    (57) expression -> . NOT expression
    (58) expression -> . LPAREN expression RPAREN
    (59) expression -> . INT_CONST
    (60) expression -> . FLOAT_CONST
    (61) expression -> . STRING_LITERAL
    (62) expression -> . CHAR_CONST
    (63) expression -> . ID

    ENDL            shift and go to state 114
    MINUS           shift and go to state 58
    NOT             shift and go to state 59
    LPAREN          shift and go to state 60
    INT_CONST       shift and go to state 61
    FLOAT_CONST     shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    CHAR_CONST      shift and go to state 64
    ID              shift and go to state 65

    insertion_item                 shift and go to state 151
    expression                     shift and go to state 113

state 142

    (89) extraction_items -> extraction_items RSHIFT . extraction_target
    (91) extraction_target -> . ID

    ID              shift and go to state 117

    extraction_target              shift and go to state 152

state 143

    (10) param -> type_specifier ID .

    RPAREN          reduce using rule 10 (param -> type_specifier ID .)
    COMMA           reduce using rule 10 (param -> type_specifier ID .)


state 144

    (6) function_def -> type_specifier ID LPAREN param_list RPAREN . block
    (17) block -> . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 35

    block                          shift and go to state 153

state 145

    (7) param_list -> param_list COMMA . param
    (10) param -> . type_specifier ID
    (11) type_specifier -> . INT
    (12) type_specifier -> . FLOAT
    (13) type_specifier -> . DOUBLE
    (14) type_specifier -> . CHAR
    (15) type_specifier -> . BOOL
    (16) type_specifier -> . STRING

    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    DOUBLE          shift and go to state 20
    CHAR            shift and go to state 21
    BOOL            shift and go to state 22
    STRING          shift and go to state 23

    param                          shift and go to state 154
    type_specifier                 shift and go to state 118

state 146

    (92) if_stmt -> IF LPAREN expression RPAREN stmt . ELSE stmt
    (93) if_stmt -> IF LPAREN expression RPAREN stmt .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 155
    INT             reduce using rule 93 (if_stmt -> IF LPAREN expression RPAREN stmt .)
    FLOAT           reduce using rule 93 (if_stmt -> IF LPAREN expression RPAREN stmt .)
    DOUBLE          reduce using rule 93 (if_stmt -> IF LPAREN expression RPAREN stmt .)
    CHAR            reduce using rule 93 (if_stmt -> IF LPAREN expression RPAREN stmt .)
    BOOL            reduce using rule 93 (if_stmt -> IF LPAREN expression RPAREN stmt .)
    STRING          reduce using rule 93 (if_stmt -> IF LPAREN expression RPAREN stmt .)
    IF              reduce using rule 93 (if_stmt -> IF LPAREN expression RPAREN stmt .)
    WHILE           reduce using rule 93 (if_stmt -> IF LPAREN expression RPAREN stmt .)
    FOR             reduce using rule 93 (if_stmt -> IF LPAREN expression RPAREN stmt .)
    RETURN          reduce using rule 93 (if_stmt -> IF LPAREN expression RPAREN stmt .)
    BREAK           reduce using rule 93 (if_stmt -> IF LPAREN expression RPAREN stmt .)
    CONTINUE        reduce using rule 93 (if_stmt -> IF LPAREN expression RPAREN stmt .)
    LBRACE          reduce using rule 93 (if_stmt -> IF LPAREN expression RPAREN stmt .)
    ID              reduce using rule 93 (if_stmt -> IF LPAREN expression RPAREN stmt .)
    COUT            reduce using rule 93 (if_stmt -> IF LPAREN expression RPAREN stmt .)
    CIN             reduce using rule 93 (if_stmt -> IF LPAREN expression RPAREN stmt .)
    $end            reduce using rule 93 (if_stmt -> IF LPAREN expression RPAREN stmt .)
    RBRACE          reduce using rule 93 (if_stmt -> IF LPAREN expression RPAREN stmt .)

  ! ELSE            [ reduce using rule 93 (if_stmt -> IF LPAREN expression RPAREN stmt .) ]


state 147

    (64) while_stmt -> WHILE LPAREN expression RPAREN stmt .

    INT             reduce using rule 64 (while_stmt -> WHILE LPAREN expression RPAREN stmt .)
    FLOAT           reduce using rule 64 (while_stmt -> WHILE LPAREN expression RPAREN stmt .)
    DOUBLE          reduce using rule 64 (while_stmt -> WHILE LPAREN expression RPAREN stmt .)
    CHAR            reduce using rule 64 (while_stmt -> WHILE LPAREN expression RPAREN stmt .)
    BOOL            reduce using rule 64 (while_stmt -> WHILE LPAREN expression RPAREN stmt .)
    STRING          reduce using rule 64 (while_stmt -> WHILE LPAREN expression RPAREN stmt .)
    IF              reduce using rule 64 (while_stmt -> WHILE LPAREN expression RPAREN stmt .)
    WHILE           reduce using rule 64 (while_stmt -> WHILE LPAREN expression RPAREN stmt .)
    FOR             reduce using rule 64 (while_stmt -> WHILE LPAREN expression RPAREN stmt .)
    RETURN          reduce using rule 64 (while_stmt -> WHILE LPAREN expression RPAREN stmt .)
    BREAK           reduce using rule 64 (while_stmt -> WHILE LPAREN expression RPAREN stmt .)
    CONTINUE        reduce using rule 64 (while_stmt -> WHILE LPAREN expression RPAREN stmt .)
    LBRACE          reduce using rule 64 (while_stmt -> WHILE LPAREN expression RPAREN stmt .)
    ID              reduce using rule 64 (while_stmt -> WHILE LPAREN expression RPAREN stmt .)
    COUT            reduce using rule 64 (while_stmt -> WHILE LPAREN expression RPAREN stmt .)
    CIN             reduce using rule 64 (while_stmt -> WHILE LPAREN expression RPAREN stmt .)
    $end            reduce using rule 64 (while_stmt -> WHILE LPAREN expression RPAREN stmt .)
    RBRACE          reduce using rule 64 (while_stmt -> WHILE LPAREN expression RPAREN stmt .)
    ELSE            reduce using rule 64 (while_stmt -> WHILE LPAREN expression RPAREN stmt .)


state 148

    (65) for_stmt -> FOR LPAREN for_init SEMICOLON for_cond . SEMICOLON for_iter RPAREN stmt

    SEMICOLON       shift and go to state 156


state 149

    (71) for_cond -> expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . TIMES expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . MOD expression
    (48) expression -> expression . EQ expression
    (49) expression -> expression . NEQ expression
    (50) expression -> expression . LT expression
    (51) expression -> expression . GT expression
    (52) expression -> expression . LE expression
    (53) expression -> expression . GE expression
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression

    SEMICOLON       reduce using rule 71 (for_cond -> expression .)
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    TIMES           shift and go to state 95
    DIVIDE          shift and go to state 96
    MOD             shift and go to state 97
    EQ              shift and go to state 98
    NEQ             shift and go to state 99
    LT              shift and go to state 100
    GT              shift and go to state 101
    LE              shift and go to state 102
    GE              shift and go to state 103
    AND             shift and go to state 104
    OR              shift and go to state 105


state 150

    (72) for_cond -> empty .

    SEMICOLON       reduce using rule 72 (for_cond -> empty .)


state 151

    (83) insertion_items -> insertion_items LSHIFT insertion_item .

    LSHIFT          reduce using rule 83 (insertion_items -> insertion_items LSHIFT insertion_item .)
    SEMICOLON       reduce using rule 83 (insertion_items -> insertion_items LSHIFT insertion_item .)


state 152

    (89) extraction_items -> extraction_items RSHIFT extraction_target .

    RSHIFT          reduce using rule 89 (extraction_items -> extraction_items RSHIFT extraction_target .)
    SEMICOLON       reduce using rule 89 (extraction_items -> extraction_items RSHIFT extraction_target .)


state 153

    (6) function_def -> type_specifier ID LPAREN param_list RPAREN block .

    INT             reduce using rule 6 (function_def -> type_specifier ID LPAREN param_list RPAREN block .)
    FLOAT           reduce using rule 6 (function_def -> type_specifier ID LPAREN param_list RPAREN block .)
    DOUBLE          reduce using rule 6 (function_def -> type_specifier ID LPAREN param_list RPAREN block .)
    CHAR            reduce using rule 6 (function_def -> type_specifier ID LPAREN param_list RPAREN block .)
    BOOL            reduce using rule 6 (function_def -> type_specifier ID LPAREN param_list RPAREN block .)
    STRING          reduce using rule 6 (function_def -> type_specifier ID LPAREN param_list RPAREN block .)
    IF              reduce using rule 6 (function_def -> type_specifier ID LPAREN param_list RPAREN block .)
    WHILE           reduce using rule 6 (function_def -> type_specifier ID LPAREN param_list RPAREN block .)
    FOR             reduce using rule 6 (function_def -> type_specifier ID LPAREN param_list RPAREN block .)
    RETURN          reduce using rule 6 (function_def -> type_specifier ID LPAREN param_list RPAREN block .)
    BREAK           reduce using rule 6 (function_def -> type_specifier ID LPAREN param_list RPAREN block .)
    CONTINUE        reduce using rule 6 (function_def -> type_specifier ID LPAREN param_list RPAREN block .)
    LBRACE          reduce using rule 6 (function_def -> type_specifier ID LPAREN param_list RPAREN block .)
    ID              reduce using rule 6 (function_def -> type_specifier ID LPAREN param_list RPAREN block .)
    COUT            reduce using rule 6 (function_def -> type_specifier ID LPAREN param_list RPAREN block .)
    CIN             reduce using rule 6 (function_def -> type_specifier ID LPAREN param_list RPAREN block .)
    $end            reduce using rule 6 (function_def -> type_specifier ID LPAREN param_list RPAREN block .)


state 154

    (7) param_list -> param_list COMMA param .

    RPAREN          reduce using rule 7 (param_list -> param_list COMMA param .)
    COMMA           reduce using rule 7 (param_list -> param_list COMMA param .)


state 155

    (92) if_stmt -> IF LPAREN expression RPAREN stmt ELSE . stmt
    (20) stmt -> . decl_stmt
    (21) stmt -> . expr_stmt
    (22) stmt -> . if_stmt
    (23) stmt -> . while_stmt
    (24) stmt -> . for_stmt
    (25) stmt -> . io_stmt
    (26) stmt -> . return_stmt
    (27) stmt -> . break_stmt
    (28) stmt -> . continue_stmt
    (29) stmt -> . block
    (30) decl_stmt -> . type_specifier init_decl SEMICOLON
    (31) decl_stmt -> . type_specifier ID SEMICOLON
    (33) expr_stmt -> . assignment SEMICOLON
    (34) expr_stmt -> . unary_inc_dec SEMICOLON
    (35) expr_stmt -> . compound_assignment SEMICOLON
    (92) if_stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (93) if_stmt -> . IF LPAREN expression RPAREN stmt
    (64) while_stmt -> . WHILE LPAREN expression RPAREN stmt
    (65) for_stmt -> . FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt
    (79) io_stmt -> . cout_stmt SEMICOLON
    (80) io_stmt -> . cin_stmt SEMICOLON
    (94) return_stmt -> . RETURN expression SEMICOLON
    (95) return_stmt -> . RETURN SEMICOLON
    (96) break_stmt -> . BREAK SEMICOLON
    (97) continue_stmt -> . CONTINUE SEMICOLON
    (17) block -> . LBRACE stmt_list RBRACE
    (11) type_specifier -> . INT
    (12) type_specifier -> . FLOAT
    (13) type_specifier -> . DOUBLE
    (14) type_specifier -> . CHAR
    (15) type_specifier -> . BOOL
    (16) type_specifier -> . STRING
    (36) assignment -> . ID ASSIGN expression
    (37) unary_inc_dec -> . ID INC
    (38) unary_inc_dec -> . ID DEC
    (39) compound_assignment -> . ID PLUS_ASSIGN expression
    (40) compound_assignment -> . ID MINUS_ASSIGN expression
    (41) compound_assignment -> . ID TIMES_ASSIGN expression
    (42) compound_assignment -> . ID DIVIDE_ASSIGN expression
    (81) cout_stmt -> . COUT insertion_list
    (87) cin_stmt -> . CIN extraction_list

    IF              shift and go to state 27
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    LBRACE          shift and go to state 35
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    DOUBLE          shift and go to state 20
    CHAR            shift and go to state 21
    BOOL            shift and go to state 22
    STRING          shift and go to state 23
    ID              shift and go to state 7
    COUT            shift and go to state 36
    CIN             shift and go to state 37

    stmt                           shift and go to state 157
    decl_stmt                      shift and go to state 9
    expr_stmt                      shift and go to state 10
    if_stmt                        shift and go to state 11
    while_stmt                     shift and go to state 12
    for_stmt                       shift and go to state 13
    io_stmt                        shift and go to state 14
    return_stmt                    shift and go to state 15
    break_stmt                     shift and go to state 16
    continue_stmt                  shift and go to state 17
    block                          shift and go to state 8
    type_specifier                 shift and go to state 91
    assignment                     shift and go to state 24
    unary_inc_dec                  shift and go to state 25
    compound_assignment            shift and go to state 26
    cout_stmt                      shift and go to state 30
    cin_stmt                       shift and go to state 31

state 156

    (65) for_stmt -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON . for_iter RPAREN stmt
    (73) for_iter -> . expr_iter
    (74) for_iter -> . empty
    (75) expr_iter -> . ID INC
    (76) expr_iter -> . ID DEC
    (77) expr_iter -> . assignment
    (78) expr_iter -> . compound_assignment
    (98) empty -> .
    (36) assignment -> . ID ASSIGN expression
    (39) compound_assignment -> . ID PLUS_ASSIGN expression
    (40) compound_assignment -> . ID MINUS_ASSIGN expression
    (41) compound_assignment -> . ID TIMES_ASSIGN expression
    (42) compound_assignment -> . ID DIVIDE_ASSIGN expression

    ID              shift and go to state 161
    RPAREN          reduce using rule 98 (empty -> .)

    for_iter                       shift and go to state 158
    expr_iter                      shift and go to state 159
    empty                          shift and go to state 160
    assignment                     shift and go to state 162
    compound_assignment            shift and go to state 163

state 157

    (92) if_stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .

    INT             reduce using rule 92 (if_stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    FLOAT           reduce using rule 92 (if_stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    DOUBLE          reduce using rule 92 (if_stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    CHAR            reduce using rule 92 (if_stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    BOOL            reduce using rule 92 (if_stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    STRING          reduce using rule 92 (if_stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    IF              reduce using rule 92 (if_stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    WHILE           reduce using rule 92 (if_stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    FOR             reduce using rule 92 (if_stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    RETURN          reduce using rule 92 (if_stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    BREAK           reduce using rule 92 (if_stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    CONTINUE        reduce using rule 92 (if_stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    LBRACE          reduce using rule 92 (if_stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    ID              reduce using rule 92 (if_stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    COUT            reduce using rule 92 (if_stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    CIN             reduce using rule 92 (if_stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    $end            reduce using rule 92 (if_stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    RBRACE          reduce using rule 92 (if_stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    ELSE            reduce using rule 92 (if_stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)


state 158

    (65) for_stmt -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter . RPAREN stmt

    RPAREN          shift and go to state 164


state 159

    (73) for_iter -> expr_iter .

    RPAREN          reduce using rule 73 (for_iter -> expr_iter .)


state 160

    (74) for_iter -> empty .

    RPAREN          reduce using rule 74 (for_iter -> empty .)


state 161

    (75) expr_iter -> ID . INC
    (76) expr_iter -> ID . DEC
    (36) assignment -> ID . ASSIGN expression
    (39) compound_assignment -> ID . PLUS_ASSIGN expression
    (40) compound_assignment -> ID . MINUS_ASSIGN expression
    (41) compound_assignment -> ID . TIMES_ASSIGN expression
    (42) compound_assignment -> ID . DIVIDE_ASSIGN expression

    INC             shift and go to state 165
    DEC             shift and go to state 166
    ASSIGN          shift and go to state 41
    PLUS_ASSIGN     shift and go to state 44
    MINUS_ASSIGN    shift and go to state 45
    TIMES_ASSIGN    shift and go to state 46
    DIVIDE_ASSIGN   shift and go to state 47


state 162

    (77) expr_iter -> assignment .

    RPAREN          reduce using rule 77 (expr_iter -> assignment .)


state 163

    (78) expr_iter -> compound_assignment .

    RPAREN          reduce using rule 78 (expr_iter -> compound_assignment .)


state 164

    (65) for_stmt -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN . stmt
    (20) stmt -> . decl_stmt
    (21) stmt -> . expr_stmt
    (22) stmt -> . if_stmt
    (23) stmt -> . while_stmt
    (24) stmt -> . for_stmt
    (25) stmt -> . io_stmt
    (26) stmt -> . return_stmt
    (27) stmt -> . break_stmt
    (28) stmt -> . continue_stmt
    (29) stmt -> . block
    (30) decl_stmt -> . type_specifier init_decl SEMICOLON
    (31) decl_stmt -> . type_specifier ID SEMICOLON
    (33) expr_stmt -> . assignment SEMICOLON
    (34) expr_stmt -> . unary_inc_dec SEMICOLON
    (35) expr_stmt -> . compound_assignment SEMICOLON
    (92) if_stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (93) if_stmt -> . IF LPAREN expression RPAREN stmt
    (64) while_stmt -> . WHILE LPAREN expression RPAREN stmt
    (65) for_stmt -> . FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt
    (79) io_stmt -> . cout_stmt SEMICOLON
    (80) io_stmt -> . cin_stmt SEMICOLON
    (94) return_stmt -> . RETURN expression SEMICOLON
    (95) return_stmt -> . RETURN SEMICOLON
    (96) break_stmt -> . BREAK SEMICOLON
    (97) continue_stmt -> . CONTINUE SEMICOLON
    (17) block -> . LBRACE stmt_list RBRACE
    (11) type_specifier -> . INT
    (12) type_specifier -> . FLOAT
    (13) type_specifier -> . DOUBLE
    (14) type_specifier -> . CHAR
    (15) type_specifier -> . BOOL
    (16) type_specifier -> . STRING
    (36) assignment -> . ID ASSIGN expression
    (37) unary_inc_dec -> . ID INC
    (38) unary_inc_dec -> . ID DEC
    (39) compound_assignment -> . ID PLUS_ASSIGN expression
    (40) compound_assignment -> . ID MINUS_ASSIGN expression
    (41) compound_assignment -> . ID TIMES_ASSIGN expression
    (42) compound_assignment -> . ID DIVIDE_ASSIGN expression
    (81) cout_stmt -> . COUT insertion_list
    (87) cin_stmt -> . CIN extraction_list

    IF              shift and go to state 27
    WHILE           shift and go to state 28
    FOR             shift and go to state 29
    RETURN          shift and go to state 32
    BREAK           shift and go to state 33
    CONTINUE        shift and go to state 34
    LBRACE          shift and go to state 35
    INT             shift and go to state 18
    FLOAT           shift and go to state 19
    DOUBLE          shift and go to state 20
    CHAR            shift and go to state 21
    BOOL            shift and go to state 22
    STRING          shift and go to state 23
    ID              shift and go to state 7
    COUT            shift and go to state 36
    CIN             shift and go to state 37

    stmt                           shift and go to state 167
    decl_stmt                      shift and go to state 9
    expr_stmt                      shift and go to state 10
    if_stmt                        shift and go to state 11
    while_stmt                     shift and go to state 12
    for_stmt                       shift and go to state 13
    io_stmt                        shift and go to state 14
    return_stmt                    shift and go to state 15
    break_stmt                     shift and go to state 16
    continue_stmt                  shift and go to state 17
    block                          shift and go to state 8
    type_specifier                 shift and go to state 91
    assignment                     shift and go to state 24
    unary_inc_dec                  shift and go to state 25
    compound_assignment            shift and go to state 26
    cout_stmt                      shift and go to state 30
    cin_stmt                       shift and go to state 31

state 165

    (75) expr_iter -> ID INC .

    RPAREN          reduce using rule 75 (expr_iter -> ID INC .)


state 166

    (76) expr_iter -> ID DEC .

    RPAREN          reduce using rule 76 (expr_iter -> ID DEC .)


state 167

    (65) for_stmt -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt .

    INT             reduce using rule 65 (for_stmt -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt .)
    FLOAT           reduce using rule 65 (for_stmt -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt .)
    DOUBLE          reduce using rule 65 (for_stmt -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt .)
    CHAR            reduce using rule 65 (for_stmt -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt .)
    BOOL            reduce using rule 65 (for_stmt -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt .)
    STRING          reduce using rule 65 (for_stmt -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt .)
    IF              reduce using rule 65 (for_stmt -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt .)
    WHILE           reduce using rule 65 (for_stmt -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt .)
    FOR             reduce using rule 65 (for_stmt -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt .)
    RETURN          reduce using rule 65 (for_stmt -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt .)
    BREAK           reduce using rule 65 (for_stmt -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt .)
    CONTINUE        reduce using rule 65 (for_stmt -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt .)
    LBRACE          reduce using rule 65 (for_stmt -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt .)
    ID              reduce using rule 65 (for_stmt -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt .)
    COUT            reduce using rule 65 (for_stmt -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt .)
    CIN             reduce using rule 65 (for_stmt -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt .)
    $end            reduce using rule 65 (for_stmt -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt .)
    RBRACE          reduce using rule 65 (for_stmt -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt .)
    ELSE            reduce using rule 65 (for_stmt -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_iter RPAREN stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 146 resolved as shift
